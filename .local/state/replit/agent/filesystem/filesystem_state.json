{"file_contents":{"main.py":{"content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nSistema de Controle de Professores DIRENS\nAplicação Desktop com Python + Tkinter\nVersão: 1.0\n\"\"\"\n\nimport tkinter as tk\nfrom tkinter import messagebox\nimport sys\nimport os\nimport logging\nfrom datetime import datetime\n\n# Adicionar o diretório atual ao path para importações\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\n\nfrom interface.login import LoginWindow\nfrom recursos.config import Config\nfrom dados.data_manager import DataManager\n\nclass SistemaDIRENS:\n    \"\"\"Classe principal do sistema DIRENS\"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa o sistema\"\"\"\n        self.setup_logging()\n        self.setup_directories()\n        self.data_manager = DataManager()\n        self.current_user = None\n        self.current_school = None\n        \n    def setup_logging(self):\n        \"\"\"Configura o sistema de logging\"\"\"\n        log_dir = \"logs\"\n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n            \n        log_filename = os.path.join(log_dir, f\"direns_{datetime.now().strftime('%Y%m%d')}.log\")\n        \n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - %(levelname)s - %(module)s - %(message)s',\n            handlers=[\n                logging.FileHandler(log_filename, encoding='utf-8'),\n                logging.StreamHandler()\n            ]\n        )\n        \n        logging.info(\"Sistema DIRENS iniciado\")\n    \n    def setup_directories(self):\n        \"\"\"Cria os diretórios necessários\"\"\"\n        directories = [\n            \"data\",\n            \"backups\", \n            \"exports\",\n            \"logs\"\n        ]\n        \n        for directory in directories:\n            if not os.path.exists(directory):\n                os.makedirs(directory)\n                logging.info(f\"Diretório criado: {directory}\")\n    \n    def run(self):\n        \"\"\"Executa o sistema\"\"\"\n        try:\n            # Cria a janela principal (invisível inicialmente)\n            root = tk.Tk()\n            root.withdraw()  # Esconde a janela principal\n            \n            # Configura o estilo da aplicação\n            root.title(\"Sistema DIRENS - Controle de Professores\")\n            root.geometry(\"1200x800\")\n            root.resizable(True, True)\n            \n            # Define ícone da aplicação (se existir)\n            try:\n                root.iconbitmap(\"recursos/icon.ico\")\n            except:\n                pass  # Ignora se não encontrar o ícone\n            \n            # Mostra a tela de login\n            login_window = LoginWindow(root, self)\n            \n            # Inicia o loop principal\n            root.mainloop()\n            \n        except Exception as e:\n            logging.error(f\"Erro fatal no sistema: {e}\")\n            messagebox.showerror(\"Erro Fatal\", f\"Erro ao iniciar o sistema:\\n{e}\")\n    \n    def on_login_success(self, user_data):\n        \"\"\"Callback executado após login bem-sucedido\"\"\"\n        self.current_user = user_data['username']\n        self.current_school = user_data['school']\n        \n        logging.info(f\"Login realizado: {self.current_user} - Escola: {self.current_school}\")\n        \n        # Importa e abre a janela principal\n        from interface.main_window import MainWindow\n        \n        # Cria a janela principal\n        root = tk.Tk()\n        app = MainWindow(root, self)\n        \n        # Centraliza a janela\n        self.center_window(root, 1200, 800)\n        \n        # Inicia o loop da janela principal\n        root.mainloop()\n    \n    def center_window(self, window, width, height):\n        \"\"\"Centraliza uma janela na tela\"\"\"\n        # Obtém as dimensões da tela\n        screen_width = window.winfo_screenwidth()\n        screen_height = window.winfo_screenheight()\n        \n        # Calcula a posição\n        x = (screen_width - width) // 2\n        y = (screen_height - height) // 2\n        \n        # Define a geometria\n        window.geometry(f\"{width}x{height}+{x}+{y}\")\n    \n    def logout(self):\n        \"\"\"Realiza o logout do sistema\"\"\"\n        logging.info(f\"Logout realizado: {self.current_user}\")\n        self.current_user = None\n        self.current_school = None\n\ndef main():\n    \"\"\"Função principal\"\"\"\n    try:\n        sistema = SistemaDIRENS()\n        sistema.run()\n    except KeyboardInterrupt:\n        logging.info(\"Sistema encerrado pelo usuário\")\n    except Exception as e:\n        logging.error(f\"Erro não tratado: {e}\")\n        print(f\"Erro fatal: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":4540},"replit.md":{"content":"# Sistema DIRENS - Teacher Management System\n\n## Overview\n\nThis is a desktop application for managing teachers in the DIRENS (Instituto Federal de Pernambuco) educational system. Built with Python and Tkinter, it provides a comprehensive interface for managing teacher data across multiple IFPE campuses. The system handles teacher registration, data validation, backup management, statistics generation, and export capabilities with a focus on Brazilian educational institution requirements.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Core Architecture Pattern\nThe application follows a modular MVC-style architecture with clear separation of concerns:\n\n- **Main Application (`main.py`)**: Entry point and system initialization\n- **Core Logic (`core/`)**: Business logic and data processing\n- **Interface Layer (`interface/`)**: Tkinter-based GUI components\n- **Data Layer (`dados/`)**: Data persistence and management\n- **Resources (`recursos/`)**: Configuration, constants, and utilities\n\n### GUI Framework\n**Tkinter Desktop Application**: Uses Python's built-in Tkinter library for cross-platform desktop GUI with modal windows and form-based interfaces. This choice provides simplicity and eliminates external GUI dependencies.\n\n### Data Storage Strategy\n**JSON File-based Storage**: All data is persisted in JSON files with file locking for concurrent access safety. This approach was chosen for:\n- Zero database server dependencies\n- Human-readable data format\n- Easy backup and portability\n- Simple deployment\n\n### Authentication System\n**File-based User Management**: User credentials are stored in encrypted JSON files with SHA-256 password hashing. Default admin accounts are automatically created for each school.\n\n### Validation Layer\n**Centralized Validation**: The `ValidatorManager` class handles all data validation including:\n- Brazilian SIAPE (7-digit teacher ID) validation\n- CPF (Brazilian tax ID) validation with checksum verification\n- Date format validation\n- Required field validation\n\n### Export and Reporting\n**Multi-format Export**: Supports both CSV and PDF export formats using:\n- `csv` module for spreadsheet exports\n- `reportlab` for PDF generation with tables and formatting\n\n### Backup Management\n**Automated Backup System**: Configurable backup schedules with:\n- ZIP compression for storage efficiency\n- Configurable retention policies\n- Manual and automatic backup triggers\n\n### History Tracking\n**Audit Trail System**: Complete change history tracking with:\n- Before/after value comparisons\n- User attribution for all changes\n- Timestamped modification logs\n\n### Error Handling and Logging\n**Comprehensive Logging**: Multi-level logging system with:\n- File-based daily logs\n- Console output for development\n- Module-specific error tracking\n\n## External Dependencies\n\n### Core Python Libraries\n- **tkinter**: GUI framework (built-in)\n- **json**: Data serialization (built-in)\n- **hashlib**: Password encryption (built-in)\n- **datetime**: Date/time handling (built-in)\n- **logging**: System logging (built-in)\n- **threading**: Concurrent operations (built-in)\n\n### Third-party Packages\n- **filelock**: File locking for concurrent access safety\n- **reportlab**: PDF generation and document formatting\n- **matplotlib**: Statistical charts and graphs generation\n\n### File System Dependencies\n- **Local JSON files**: Primary data storage\n- **Directory structure**: Organized data, logs, backups, and exports folders\n- **Configuration files**: JSON-based system configuration\n\n### Integration Points\n- **Brazilian Educational System**: SIAPE teacher identification integration\n- **IFPE Campus Network**: Multi-campus teacher management\n- **Government Standards**: CPF validation and Brazilian date formats","size_bytes":3801},"core/__init__.py":{"content":"\"\"\"\nMódulo Core do Sistema DIRENS\nContém a lógica de negócio principal\n\"\"\"\n\n__version__ = \"1.0.0\"\n__author__ = \"Sistema DIRENS\"\n\n","size_bytes":133},"core/auth.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nMódulo de Autenticação do Sistema DIRENS\n\"\"\"\n\nimport hashlib\nimport json\nimport os\nimport logging\nfrom datetime import datetime\n\nfrom recursos.constants import ESCOLAS\n\nclass AuthManager:\n    \"\"\"Gerenciador de autenticação\"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa o gerenciador de autenticação\"\"\"\n        self.users_file = \"data/users.json\"\n        self.ensure_data_directory()\n        self.initialize_default_users()\n    \n    def ensure_data_directory(self):\n        \"\"\"Garante que o diretório de dados existe\"\"\"\n        data_dir = os.path.dirname(self.users_file)\n        if not os.path.exists(data_dir):\n            os.makedirs(data_dir)\n    \n    def initialize_default_users(self):\n        \"\"\"Inicializa usuários padrão se não existirem\"\"\"\n        if not os.path.exists(self.users_file):\n            default_users = {}\n            \n            # Cria usuário admin padrão para cada escola\n            for escola in ESCOLAS.keys():\n                escola_key = escola.replace(\" \", \"_\").lower()\n                default_users[escola_key] = {\n                    \"admin\": {\n                        \"password\": self.hash_password(\"direns2024\"),\n                        \"level\": \"admin\",\n                        \"created_at\": datetime.now().isoformat(),\n                        \"last_login\": None,\n                        \"active\": True\n                    }\n                }\n            \n            self.save_users(default_users)\n            logging.info(\"Usuários padrão criados\")\n    \n    def hash_password(self, password):\n        \"\"\"Cria hash da senha\"\"\"\n        return hashlib.sha256(password.encode('utf-8')).hexdigest()\n    \n    def load_users(self):\n        \"\"\"Carrega usuários do arquivo\"\"\"\n        try:\n            if os.path.exists(self.users_file):\n                with open(self.users_file, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n            return {}\n        except Exception as e:\n            logging.error(f\"Erro ao carregar usuários: {e}\")\n            return {}\n    \n    def save_users(self, users):\n        \"\"\"Salva usuários no arquivo\"\"\"\n        try:\n            with open(self.users_file, 'w', encoding='utf-8') as f:\n                json.dump(users, f, indent=2, ensure_ascii=False)\n        except Exception as e:\n            logging.error(f\"Erro ao salvar usuários: {e}\")\n            raise\n    \n    def get_school_key(self, school):\n        \"\"\"Converte nome da escola para chave\"\"\"\n        return school.replace(\" \", \"_\").lower()\n    \n    def authenticate(self, school, username, password):\n        \"\"\"Autentica usuário\"\"\"\n        try:\n            users = self.load_users()\n            school_key = self.get_school_key(school)\n            \n            # Verifica se escola existe\n            if school_key not in users:\n                return {\n                    'success': False,\n                    'message': 'Escola não encontrada'\n                }\n            \n            # Verifica se usuário existe\n            if username not in users[school_key]:\n                return {\n                    'success': False,\n                    'message': 'Usuário não encontrado'\n                }\n            \n            user_data = users[school_key][username]\n            \n            # Verifica se usuário está ativo\n            if not user_data.get('active', True):\n                return {\n                    'success': False,\n                    'message': 'Usuário desativado'\n                }\n            \n            # Verifica senha\n            password_hash = self.hash_password(password)\n            if password_hash != user_data.get('password'):\n                return {\n                    'success': False,\n                    'message': 'Senha incorreta'\n                }\n            \n            # Atualiza último login\n            user_data['last_login'] = datetime.now().isoformat()\n            users[school_key][username] = user_data\n            self.save_users(users)\n            \n            logging.info(f\"Login bem-sucedido: {username} - {school}\")\n            \n            return {\n                'success': True,\n                'message': 'Login realizado com sucesso',\n                'level': user_data.get('level', 'user')\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro na autenticação: {e}\")\n            return {\n                'success': False,\n                'message': 'Erro interno do sistema'\n            }\n    \n    def reset_password(self, school, username, current_password, new_password, is_admin=False):\n        \"\"\"Redefine senha de usuário\"\"\"\n        try:\n            users = self.load_users()\n            school_key = self.get_school_key(school)\n            \n            # Verifica se escola existe\n            if school_key not in users:\n                return {\n                    'success': False,\n                    'message': 'Escola não encontrada'\n                }\n            \n            # Verifica se usuário existe\n            if username not in users[school_key]:\n                return {\n                    'success': False,\n                    'message': 'Usuário não encontrado'\n                }\n            \n            user_data = users[school_key][username]\n            \n            # Se não é admin, verifica senha atual\n            if not is_admin:\n                current_hash = self.hash_password(current_password)\n                if current_hash != user_data.get('password'):\n                    return {\n                        'success': False,\n                        'message': 'Senha atual incorreta'\n                    }\n            else:\n                # Verifica se quem está fazendo a alteração é realmente admin\n                # Para simplificar, aceitamos a flag is_admin\n                # Em uma implementação mais robusta, verificaríamos a sessão atual\n                pass\n            \n            # Valida nova senha\n            if len(new_password) < 6:\n                return {\n                    'success': False,\n                    'message': 'Nova senha deve ter pelo menos 6 caracteres'\n                }\n            \n            # Atualiza senha\n            user_data['password'] = self.hash_password(new_password)\n            user_data['password_changed_at'] = datetime.now().isoformat()\n            \n            users[school_key][username] = user_data\n            self.save_users(users)\n            \n            logging.info(f\"Senha redefinida: {username} - {school}\")\n            \n            return {\n                'success': True,\n                'message': 'Senha alterada com sucesso'\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro ao redefinir senha: {e}\")\n            return {\n                'success': False,\n                'message': 'Erro interno do sistema'\n            }\n    \n    def create_user(self, school, username, password, level='user'):\n        \"\"\"Cria novo usuário\"\"\"\n        try:\n            users = self.load_users()\n            school_key = self.get_school_key(school)\n            \n            # Cria escola se não existir\n            if school_key not in users:\n                users[school_key] = {}\n            \n            # Verifica se usuário já existe\n            if username in users[school_key]:\n                return {\n                    'success': False,\n                    'message': 'Usuário já existe'\n                }\n            \n            # Valida dados\n            if len(username.strip()) < 3:\n                return {\n                    'success': False,\n                    'message': 'Nome de usuário deve ter pelo menos 3 caracteres'\n                }\n            \n            if len(password) < 6:\n                return {\n                    'success': False,\n                    'message': 'Senha deve ter pelo menos 6 caracteres'\n                }\n            \n            if level not in ['user', 'admin']:\n                return {\n                    'success': False,\n                    'message': 'Nível deve ser \"user\" ou \"admin\"'\n                }\n            \n            # Cria usuário\n            users[school_key][username] = {\n                'password': self.hash_password(password),\n                'level': level,\n                'created_at': datetime.now().isoformat(),\n                'last_login': None,\n                'active': True\n            }\n            \n            self.save_users(users)\n            \n            logging.info(f\"Usuário criado: {username} - {school} - {level}\")\n            \n            return {\n                'success': True,\n                'message': 'Usuário criado com sucesso'\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro ao criar usuário: {e}\")\n            return {\n                'success': False,\n                'message': 'Erro interno do sistema'\n            }\n    \n    def list_users(self, school):\n        \"\"\"Lista usuários de uma escola\"\"\"\n        try:\n            users = self.load_users()\n            school_key = self.get_school_key(school)\n            \n            if school_key not in users:\n                return []\n            \n            user_list = []\n            for username, data in users[school_key].items():\n                user_info = {\n                    'username': username,\n                    'level': data.get('level', 'user'),\n                    'active': data.get('active', True),\n                    'created_at': data.get('created_at'),\n                    'last_login': data.get('last_login')\n                }\n                user_list.append(user_info)\n            \n            return user_list\n            \n        except Exception as e:\n            logging.error(f\"Erro ao listar usuários: {e}\")\n            return []\n    \n    def deactivate_user(self, school, username):\n        \"\"\"Desativa usuário\"\"\"\n        try:\n            users = self.load_users()\n            school_key = self.get_school_key(school)\n            \n            if school_key not in users or username not in users[school_key]:\n                return {\n                    'success': False,\n                    'message': 'Usuário não encontrado'\n                }\n            \n            # Não permite desativar o último admin\n            if users[school_key][username].get('level') == 'admin':\n                admins = [u for u, d in users[school_key].items() \n                         if d.get('level') == 'admin' and d.get('active', True)]\n                \n                if len(admins) <= 1:\n                    return {\n                        'success': False,\n                        'message': 'Não é possível desativar o último administrador'\n                    }\n            \n            users[school_key][username]['active'] = False\n            users[school_key][username]['deactivated_at'] = datetime.now().isoformat()\n            \n            self.save_users(users)\n            \n            logging.info(f\"Usuário desativado: {username} - {school}\")\n            \n            return {\n                'success': True,\n                'message': 'Usuário desativado com sucesso'\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro ao desativar usuário: {e}\")\n            return {\n                'success': False,\n                'message': 'Erro interno do sistema'\n            }\n    \n    def activate_user(self, school, username):\n        \"\"\"Ativa usuário\"\"\"\n        try:\n            users = self.load_users()\n            school_key = self.get_school_key(school)\n            \n            if school_key not in users or username not in users[school_key]:\n                return {\n                    'success': False,\n                    'message': 'Usuário não encontrado'\n                }\n            \n            users[school_key][username]['active'] = True\n            if 'deactivated_at' in users[school_key][username]:\n                del users[school_key][username]['deactivated_at']\n            \n            self.save_users(users)\n            \n            logging.info(f\"Usuário ativado: {username} - {school}\")\n            \n            return {\n                'success': True,\n                'message': 'Usuário ativado com sucesso'\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro ao ativar usuário: {e}\")\n            return {\n                'success': False,\n                'message': 'Erro interno do sistema'\n            }\n","size_bytes":12574},"core/backup_manager.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nGerenciador de Backups - Sistema DIRENS\n\"\"\"\n\nimport os\nimport json\nimport shutil\nimport zipfile\nimport logging\nfrom datetime import datetime, timedelta\nimport tempfile\n\nclass BackupManager:\n    \"\"\"Gerenciador de backups do sistema\"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa o gerenciador de backups\"\"\"\n        self.backup_dir = \"backups\"\n        self.data_dir = \"data\"\n        self.config_file = os.path.join(self.backup_dir, \"backup_config.json\")\n        self.ensure_backup_directory()\n        self.load_config()\n    \n    def ensure_backup_directory(self):\n        \"\"\"Garante que o diretório de backups existe\"\"\"\n        if not os.path.exists(self.backup_dir):\n            os.makedirs(self.backup_dir)\n    \n    def load_config(self):\n        \"\"\"Carrega configurações de backup\"\"\"\n        default_config = {\n            'auto_backup_enabled': True,\n            'auto_backup_interval_hours': 24,\n            'max_backups': 30,\n            'last_backup': None\n        }\n        \n        try:\n            if os.path.exists(self.config_file):\n                with open(self.config_file, 'r', encoding='utf-8') as f:\n                    self.config = json.load(f)\n            else:\n                self.config = default_config\n                self.save_config()\n        except Exception as e:\n            logging.error(f\"Erro ao carregar config de backup: {e}\")\n            self.config = default_config\n    \n    def save_config(self):\n        \"\"\"Salva configurações de backup\"\"\"\n        try:\n            with open(self.config_file, 'w', encoding='utf-8') as f:\n                json.dump(self.config, f, indent=2, ensure_ascii=False)\n        except Exception as e:\n            logging.error(f\"Erro ao salvar config de backup: {e}\")\n    \n    def create_backup(self, description=\"\", backup_type=\"manual\", include_history=True):\n        \"\"\"Cria um novo backup\"\"\"\n        try:\n            timestamp = datetime.now()\n            timestamp_str = timestamp.strftime(\"%Y%m%d_%H%M%S\")\n            \n            backup_name = f\"backup_{timestamp_str}\"\n            backup_filename = f\"{backup_name}.zip\"\n            backup_path = os.path.join(self.backup_dir, backup_filename)\n            \n            # Cria arquivo ZIP\n            with zipfile.ZipFile(backup_path, 'w', zipfile.ZIP_DEFLATED) as zipf:\n                # Adiciona todos os arquivos de dados\n                if os.path.exists(self.data_dir):\n                    for root, dirs, files in os.walk(self.data_dir):\n                        for file in files:\n                            file_path = os.path.join(root, file)\n                            # Calcula path relativo\n                            arcname = os.path.relpath(file_path, '.')\n                            zipf.write(file_path, arcname)\n                \n                # Adiciona logs se solicitado\n                if include_history and os.path.exists(\"logs\"):\n                    for root, dirs, files in os.walk(\"logs\"):\n                        for file in files:\n                            if file.endswith('.log'):\n                                file_path = os.path.join(root, file)\n                                arcname = os.path.relpath(file_path, '.')\n                                zipf.write(file_path, arcname)\n            \n            # Salva metadados do backup\n            backup_info = {\n                'name': backup_name,\n                'filename': backup_filename,\n                'filepath': backup_path,\n                'timestamp': timestamp.isoformat(),\n                'type': backup_type,\n                'description': description or f\"Backup {backup_type} - {timestamp.strftime('%d/%m/%Y %H:%M')}\",\n                'size': os.path.getsize(backup_path),\n                'status': 'OK',\n                'include_history': include_history\n            }\n            \n            # Salva registro do backup\n            self.save_backup_info(backup_info)\n            \n            # Atualiza config\n            self.config['last_backup'] = timestamp.isoformat()\n            self.save_config()\n            \n            # Limpa backups antigos\n            self.cleanup_old_backups()\n            \n            logging.info(f\"Backup criado: {backup_filename}\")\n            return backup_info\n            \n        except Exception as e:\n            logging.error(f\"Erro ao criar backup: {e}\")\n            return None\n    \n    def list_backups(self):\n        \"\"\"Lista todos os backups disponíveis\"\"\"\n        try:\n            backups = []\n            backup_index_file = os.path.join(self.backup_dir, \"backup_index.json\")\n            \n            if os.path.exists(backup_index_file):\n                with open(backup_index_file, 'r', encoding='utf-8') as f:\n                    backup_index = json.load(f)\n                    backups = backup_index.get('backups', [])\n            \n            # Verifica se os arquivos ainda existem\n            valid_backups = []\n            for backup in backups:\n                filepath = backup.get('filepath', '')\n                if os.path.exists(filepath):\n                    # Atualiza tamanho se necessário\n                    backup['size'] = os.path.getsize(filepath)\n                    valid_backups.append(backup)\n                else:\n                    logging.warning(f\"Arquivo de backup não encontrado: {filepath}\")\n            \n            return valid_backups\n            \n        except Exception as e:\n            logging.error(f\"Erro ao listar backups: {e}\")\n            return []\n    \n    def save_backup_info(self, backup_info):\n        \"\"\"Salva informações de um backup no índice\"\"\"\n        try:\n            backup_index_file = os.path.join(self.backup_dir, \"backup_index.json\")\n            \n            # Carrega índice atual\n            if os.path.exists(backup_index_file):\n                with open(backup_index_file, 'r', encoding='utf-8') as f:\n                    backup_index = json.load(f)\n            else:\n                backup_index = {'backups': []}\n            \n            # Adiciona novo backup\n            backup_index['backups'].append(backup_info)\n            \n            # Salva índice atualizado\n            with open(backup_index_file, 'w', encoding='utf-8') as f:\n                json.dump(backup_index, f, indent=2, ensure_ascii=False)\n                \n        except Exception as e:\n            logging.error(f\"Erro ao salvar info do backup: {e}\")\n    \n    def restore_backup(self, backup_name):\n        \"\"\"Restaura um backup específico\"\"\"\n        try:\n            # Encontra o backup\n            backups = self.list_backups()\n            backup_info = None\n            \n            for backup in backups:\n                if backup['name'] == backup_name:\n                    backup_info = backup\n                    break\n            \n            if not backup_info:\n                logging.error(f\"Backup não encontrado: {backup_name}\")\n                return False\n            \n            backup_file = backup_info['filepath']\n            if not os.path.exists(backup_file):\n                logging.error(f\"Arquivo de backup não existe: {backup_file}\")\n                return False\n            \n            # Cria backup da situação atual antes da restauração\n            self.create_backup(\n                description=\"Backup automático antes da restauração\",\n                backup_type=\"pre_restore\"\n            )\n            \n            # Cria diretório temporário\n            with tempfile.TemporaryDirectory() as temp_dir:\n                # Extrai backup\n                with zipfile.ZipFile(backup_file, 'r') as zipf:\n                    zipf.extractall(temp_dir)\n                \n                # Remove dados atuais (backup já foi feito)\n                if os.path.exists(self.data_dir):\n                    shutil.rmtree(self.data_dir)\n                \n                # Restaura dados do backup\n                backup_data_dir = os.path.join(temp_dir, 'data')\n                if os.path.exists(backup_data_dir):\n                    shutil.copytree(backup_data_dir, self.data_dir)\n                \n                # Restaura logs se existirem no backup\n                backup_logs_dir = os.path.join(temp_dir, 'logs')\n                if os.path.exists(backup_logs_dir) and backup_info.get('include_history', True):\n                    if not os.path.exists('logs'):\n                        os.makedirs('logs')\n                    \n                    for file in os.listdir(backup_logs_dir):\n                        src = os.path.join(backup_logs_dir, file)\n                        dst = os.path.join('logs', file)\n                        shutil.copy2(src, dst)\n            \n            logging.info(f\"Backup restaurado: {backup_name}\")\n            return True\n            \n        except Exception as e:\n            logging.error(f\"Erro ao restaurar backup: {e}\")\n            return False\n    \n    def delete_backup(self, backup_name):\n        \"\"\"Exclui um backup específico\"\"\"\n        try:\n            # Encontra o backup\n            backups = self.list_backups()\n            backup_to_delete = None\n            \n            for backup in backups:\n                if backup['name'] == backup_name:\n                    backup_to_delete = backup\n                    break\n            \n            if not backup_to_delete:\n                logging.error(f\"Backup não encontrado: {backup_name}\")\n                return False\n            \n            # Remove arquivo físico\n            backup_file = backup_to_delete['filepath']\n            if os.path.exists(backup_file):\n                os.remove(backup_file)\n            \n            # Remove do índice\n            backup_index_file = os.path.join(self.backup_dir, \"backup_index.json\")\n            if os.path.exists(backup_index_file):\n                with open(backup_index_file, 'r', encoding='utf-8') as f:\n                    backup_index = json.load(f)\n                \n                # Remove backup do índice\n                backup_index['backups'] = [\n                    b for b in backup_index['backups'] \n                    if b['name'] != backup_name\n                ]\n                \n                # Salva índice atualizado\n                with open(backup_index_file, 'w', encoding='utf-8') as f:\n                    json.dump(backup_index, f, indent=2, ensure_ascii=False)\n            \n            logging.info(f\"Backup excluído: {backup_name}\")\n            return True\n            \n        except Exception as e:\n            logging.error(f\"Erro ao excluir backup: {e}\")\n            return False\n    \n    def export_backup(self, backup_name, destination_path):\n        \"\"\"Exporta backup para local específico\"\"\"\n        try:\n            # Encontra o backup\n            backups = self.list_backups()\n            backup_info = None\n            \n            for backup in backups:\n                if backup['name'] == backup_name:\n                    backup_info = backup\n                    break\n            \n            if not backup_info:\n                logging.error(f\"Backup não encontrado: {backup_name}\")\n                return False\n            \n            source_file = backup_info['filepath']\n            if not os.path.exists(source_file):\n                logging.error(f\"Arquivo de backup não existe: {source_file}\")\n                return False\n            \n            # Copia arquivo\n            shutil.copy2(source_file, destination_path)\n            \n            logging.info(f\"Backup exportado: {backup_name} -> {destination_path}\")\n            return True\n            \n        except Exception as e:\n            logging.error(f\"Erro ao exportar backup: {e}\")\n            return False\n    \n    def cleanup_old_backups(self):\n        \"\"\"Remove backups antigos baseado na configuração\"\"\"\n        try:\n            max_backups = self.config.get('max_backups', 30)\n            backups = self.list_backups()\n            \n            if len(backups) <= max_backups:\n                return\n            \n            # Ordena por data (mais antigo primeiro)\n            backups.sort(key=lambda x: x.get('timestamp', ''))\n            \n            # Remove os mais antigos\n            backups_to_remove = backups[:-max_backups]\n            \n            for backup in backups_to_remove:\n                # Não remove backups de restauração\n                if backup.get('type') != 'pre_restore':\n                    self.delete_backup(backup['name'])\n                    logging.info(f\"Backup antigo removido: {backup['name']}\")\n            \n        except Exception as e:\n            logging.error(f\"Erro na limpeza de backups: {e}\")\n    \n    def is_auto_backup_enabled(self):\n        \"\"\"Verifica se backup automático está habilitado\"\"\"\n        return self.config.get('auto_backup_enabled', True)\n    \n    def set_auto_backup(self, enabled):\n        \"\"\"Habilita/desabilita backup automático\"\"\"\n        self.config['auto_backup_enabled'] = enabled\n        self.save_config()\n        logging.info(f\"Backup automático {'habilitado' if enabled else 'desabilitado'}\")\n    \n    def should_create_auto_backup(self):\n        \"\"\"Verifica se deve criar backup automático\"\"\"\n        if not self.is_auto_backup_enabled():\n            return False\n        \n        last_backup = self.config.get('last_backup')\n        if not last_backup:\n            return True\n        \n        try:\n            last_backup_time = datetime.fromisoformat(last_backup)\n            interval_hours = self.config.get('auto_backup_interval_hours', 24)\n            \n            time_diff = datetime.now() - last_backup_time\n            return time_diff.total_seconds() > (interval_hours * 3600)\n            \n        except Exception:\n            return True\n    \n    def create_auto_backup_if_needed(self):\n        \"\"\"Cria backup automático se necessário\"\"\"\n        if self.should_create_auto_backup():\n            try:\n                self.create_backup(\n                    description=\"Backup automático\",\n                    backup_type=\"auto\"\n                )\n                logging.info(\"Backup automático criado\")\n                return True\n            except Exception as e:\n                logging.error(f\"Erro no backup automático: {e}\")\n                return False\n        return False\n    \n    def get_backup_statistics(self):\n        \"\"\"Retorna estatísticas dos backups\"\"\"\n        try:\n            backups = self.list_backups()\n            \n            if not backups:\n                return {\n                    'total_backups': 0,\n                    'total_size': 0,\n                    'oldest_backup': None,\n                    'newest_backup': None,\n                    'auto_backups': 0,\n                    'manual_backups': 0\n                }\n            \n            total_size = sum(backup.get('size', 0) for backup in backups)\n            auto_backups = len([b for b in backups if b.get('type') == 'auto'])\n            manual_backups = len([b for b in backups if b.get('type') == 'manual'])\n            \n            # Ordena por data\n            sorted_backups = sorted(backups, key=lambda x: x.get('timestamp', ''))\n            \n            return {\n                'total_backups': len(backups),\n                'total_size': total_size,\n                'oldest_backup': sorted_backups[0].get('timestamp') if sorted_backups else None,\n                'newest_backup': sorted_backups[-1].get('timestamp') if sorted_backups else None,\n                'auto_backups': auto_backups,\n                'manual_backups': manual_backups\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro ao gerar estatísticas de backup: {e}\")\n            return {}\n","size_bytes":15681},"core/export_manager.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nGerenciador de Exportações - Sistema DIRENS\n\"\"\"\n\nimport csv\nimport os\nimport logging\nfrom datetime import datetime\nfrom reportlab.lib.pagesizes import A4, letter\nfrom reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.lib.units import inch\nfrom reportlab.lib import colors\nfrom reportlab.lib.enums import TA_CENTER, TA_LEFT\n\nclass ExportManager:\n    \"\"\"Gerenciador de exportações para CSV e PDF\"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa o gerenciador de exportações\"\"\"\n        self.exports_dir = \"exports\"\n        self.ensure_exports_directory()\n    \n    def ensure_exports_directory(self):\n        \"\"\"Garante que o diretório de exportações existe\"\"\"\n        if not os.path.exists(self.exports_dir):\n            os.makedirs(self.exports_dir)\n    \n    def export_csv(self, teachers, school):\n        \"\"\"Exporta professores para CSV\"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"professores_{school.replace(' ', '_')}_{timestamp}.csv\"\n            filepath = os.path.join(self.exports_dir, filename)\n            \n            with open(filepath, 'w', newline='', encoding='utf-8-sig') as csvfile:\n                fieldnames = [\n                    'SIAPE', 'Nome', 'CPF', 'Data Nascimento', 'Sexo', 'Estado Civil',\n                    'Carga Horária', 'Carreira', 'Data Ingresso', 'Status', 'Área Atuação',\n                    'Pós-graduação', 'Graduação', 'Instituição Graduação',\n                    'Curso Pós', 'Instituição Pós', 'Email', 'Telefone'\n                ]\n                \n                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n                writer.writeheader()\n                \n                for teacher in teachers:\n                    writer.writerow({\n                        'SIAPE': teacher.get('siape', ''),\n                        'Nome': teacher.get('nome', ''),\n                        'CPF': teacher.get('cpf', ''),\n                        'Data Nascimento': teacher.get('data_nascimento', ''),\n                        'Sexo': teacher.get('sexo', ''),\n                        'Estado Civil': teacher.get('estado_civil', ''),\n                        'Carga Horária': teacher.get('carga_horaria', ''),\n                        'Carreira': teacher.get('carreira', ''),\n                        'Data Ingresso': teacher.get('data_ingresso', ''),\n                        'Status': teacher.get('status', 'Ativo'),\n                        'Área Atuação': teacher.get('area_atuacao', ''),\n                        'Pós-graduação': teacher.get('pos_graduacao', ''),\n                        'Graduação': teacher.get('graduacao', ''),\n                        'Instituição Graduação': teacher.get('instituicao_graduacao', ''),\n                        'Curso Pós': teacher.get('curso_pos', ''),\n                        'Instituição Pós': teacher.get('instituicao_pos', ''),\n                        'Email': teacher.get('email', ''),\n                        'Telefone': teacher.get('telefone', '')\n                    })\n            \n            logging.info(f\"CSV exportado: {filepath}\")\n            return filepath\n            \n        except Exception as e:\n            logging.error(f\"Erro ao exportar CSV: {e}\")\n            raise\n    \n    def export_pdf(self, teachers, school):\n        \"\"\"Exporta professores para PDF\"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"relatorio_professores_{school.replace(' ', '_')}_{timestamp}.pdf\"\n            filepath = os.path.join(self.exports_dir, filename)\n            \n            # Cria documento PDF\n            doc = SimpleDocTemplate(\n                filepath,\n                pagesize=A4,\n                rightMargin=30,\n                leftMargin=30,\n                topMargin=30,\n                bottomMargin=30\n            )\n            \n            # Estilos\n            styles = getSampleStyleSheet()\n            title_style = ParagraphStyle(\n                'CustomTitle',\n                parent=styles['Heading1'],\n                fontSize=16,\n                spaceAfter=30,\n                alignment=TA_CENTER\n            )\n            \n            subtitle_style = ParagraphStyle(\n                'CustomSubtitle',\n                parent=styles['Heading2'],\n                fontSize=12,\n                spaceAfter=20,\n                alignment=TA_LEFT\n            )\n            \n            # Elementos do documento\n            elements = []\n            \n            # Título\n            title = Paragraph(f\"RELATÓRIO DE PROFESSORES<br/>{school}\", title_style)\n            elements.append(title)\n            \n            # Informações gerais\n            info_text = f\"\"\"\n            <b>Data de Geração:</b> {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}<br/>\n            <b>Total de Professores:</b> {len(teachers)}<br/>\n            <b>Sistema:</b> DIRENS - Controle de Professores v1.0\n            \"\"\"\n            \n            info_para = Paragraph(info_text, styles['Normal'])\n            elements.append(info_para)\n            elements.append(Spacer(1, 20))\n            \n            # Estatísticas resumidas\n            stats = self.generate_statistics(teachers)\n            if stats:\n                elements.append(Paragraph(\"ESTATÍSTICAS RESUMIDAS\", subtitle_style))\n                \n                stats_data = [\n                    ['Categoria', 'Quantidade', 'Percentual'],\n                    ['Professores Ativos', str(stats['ativos']), f\"{(stats['ativos']/len(teachers)*100):.1f}%\" if teachers else \"0%\"],\n                    ['40H Dedicação Exclusiva', str(stats['de_40h']), f\"{(stats['de_40h']/len(teachers)*100):.1f}%\" if teachers else \"0%\"],\n                    ['Com Doutorado', str(stats['doutorado']), f\"{(stats['doutorado']/len(teachers)*100):.1f}%\" if teachers else \"0%\"],\n                    ['Com Mestrado', str(stats['mestrado']), f\"{(stats['mestrado']/len(teachers)*100):.1f}%\" if teachers else \"0%\"],\n                    ['Carreira EBTT', str(stats['ebtt']), f\"{(stats['ebtt']/len(teachers)*100):.1f}%\" if teachers else \"0%\"]\n                ]\n                \n                stats_table = Table(stats_data)\n                stats_table.setStyle(TableStyle([\n                    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n                    ('FONTSIZE', (0, 0), (-1, 0), 10),\n                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\n                    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n                    ('GRID', (0, 0), (-1, -1), 1, colors.black)\n                ]))\n                \n                elements.append(stats_table)\n                elements.append(Spacer(1, 20))\n            \n            # Lista de professores\n            if teachers:\n                elements.append(PageBreak())\n                elements.append(Paragraph(\"LISTA COMPLETA DE PROFESSORES\", subtitle_style))\n                \n                # Cabeçalho da tabela\n                table_data = [\n                    ['SIAPE', 'Nome', 'Carreira', 'Carga H.', 'Pós-grad.', 'Status']\n                ]\n                \n                # Dados dos professores\n                for teacher in sorted(teachers, key=lambda x: x.get('nome', '')):\n                    table_data.append([\n                        teacher.get('siape', '')[:7],  # Limita tamanho\n                        teacher.get('nome', '')[:30],  # Limita tamanho\n                        teacher.get('carreira', '')[:8],\n                        teacher.get('carga_horaria', '')[:8],\n                        teacher.get('pos_graduacao', '')[:12],\n                        teacher.get('status', 'Ativo')[:10]\n                    ])\n                \n                # Cria tabela\n                teachers_table = Table(table_data, repeatRows=1)\n                teachers_table.setStyle(TableStyle([\n                    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n                    ('FONTSIZE', (0, 0), (-1, 0), 8),\n                    ('FONTSIZE', (0, 1), (-1, -1), 7),\n                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\n                    ('BACKGROUND', (0, 1), (-1, -1), colors.white),\n                    ('GRID', (0, 0), (-1, -1), 1, colors.black),\n                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE')\n                ]))\n                \n                elements.append(teachers_table)\n            \n            # Rodapé\n            elements.append(Spacer(1, 30))\n            footer_text = f\"Relatório gerado pelo Sistema DIRENS - {datetime.now().strftime('%d/%m/%Y %H:%M')}\"\n            footer = Paragraph(footer_text, styles['Normal'])\n            elements.append(footer)\n            \n            # Gera o PDF\n            doc.build(elements)\n            \n            logging.info(f\"PDF exportado: {filepath}\")\n            return filepath\n            \n        except Exception as e:\n            logging.error(f\"Erro ao exportar PDF: {e}\")\n            raise\n    \n    def generate_statistics(self, teachers):\n        \"\"\"Gera estatísticas para o relatório\"\"\"\n        if not teachers:\n            return None\n        \n        total = len(teachers)\n        ativos = len([t for t in teachers if t.get('status', 'Ativo') == 'Ativo'])\n        de_40h = len([t for t in teachers if t.get('carga_horaria') == '40H_DE'])\n        doutorado = len([t for t in teachers if t.get('pos_graduacao') == 'DOUTORADO'])\n        mestrado = len([t for t in teachers if t.get('pos_graduacao') == 'MESTRADO'])\n        ebtt = len([t for t in teachers if t.get('carreira') == 'EBTT'])\n        \n        return {\n            'total': total,\n            'ativos': ativos,\n            'de_40h': de_40h,\n            'doutorado': doutorado,\n            'mestrado': mestrado,\n            'ebtt': ebtt\n        }\n    \n    def export_detailed_pdf(self, teachers, school):\n        \"\"\"Exporta relatório PDF detalhado com todos os campos\"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"relatorio_detalhado_{school.replace(' ', '_')}_{timestamp}.pdf\"\n            filepath = os.path.join(self.exports_dir, filename)\n            \n            doc = SimpleDocTemplate(\n                filepath,\n                pagesize=letter,\n                rightMargin=20,\n                leftMargin=20,\n                topMargin=30,\n                bottomMargin=30\n            )\n            \n            elements = []\n            styles = getSampleStyleSheet()\n            \n            # Título\n            title_style = ParagraphStyle(\n                'CustomTitle',\n                parent=styles['Heading1'],\n                fontSize=14,\n                spaceAfter=20,\n                alignment=TA_CENTER\n            )\n            \n            title = Paragraph(f\"RELATÓRIO DETALHADO DE PROFESSORES - {school}\", title_style)\n            elements.append(title)\n            \n            # Para cada professor, criar uma página ou seção\n            for i, teacher in enumerate(sorted(teachers, key=lambda x: x.get('nome', ''))):\n                if i > 0:\n                    elements.append(PageBreak())\n                \n                # Nome do professor\n                name_style = ParagraphStyle(\n                    'TeacherName',\n                    parent=styles['Heading2'],\n                    fontSize=12,\n                    spaceAfter=15,\n                    alignment=TA_LEFT\n                )\n                \n                name = Paragraph(f\"{i+1:03d}. {teacher.get('nome', 'N/A')}\", name_style)\n                elements.append(name)\n                \n                # Dados em tabela\n                teacher_data = [\n                    ['Campo', 'Valor'],\n                    ['SIAPE', teacher.get('siape', '')],\n                    ['CPF', teacher.get('cpf', '')],\n                    ['Data de Nascimento', teacher.get('data_nascimento', '')],\n                    ['Sexo', teacher.get('sexo', '')],\n                    ['Estado Civil', teacher.get('estado_civil', '')],\n                    ['Carga Horária', teacher.get('carga_horaria', '')],\n                    ['Carreira', teacher.get('carreira', '')],\n                    ['Data de Ingresso', teacher.get('data_ingresso', '')],\n                    ['Status', teacher.get('status', 'Ativo')],\n                    ['Área de Atuação', teacher.get('area_atuacao', '')],\n                    ['Pós-graduação', teacher.get('pos_graduacao', '')],\n                    ['Graduação', teacher.get('graduacao', '')],\n                    ['Instituição Graduação', teacher.get('instituicao_graduacao', '')],\n                    ['Curso Pós-graduação', teacher.get('curso_pos', '')],\n                    ['Instituição Pós', teacher.get('instituicao_pos', '')],\n                    ['Email', teacher.get('email', '')],\n                    ['Telefone', teacher.get('telefone', '')]\n                ]\n                \n                teacher_table = Table(teacher_data, colWidths=[2*inch, 4*inch])\n                teacher_table.setStyle(TableStyle([\n                    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n                    ('ALIGN', (0, 0), (0, -1), 'RIGHT'),\n                    ('ALIGN', (1, 0), (1, -1), 'LEFT'),\n                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n                    ('FONTNAME', (0, 1), (0, -1), 'Helvetica-Bold'),\n                    ('FONTSIZE', (0, 0), (-1, -1), 9),\n                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\n                    ('BACKGROUND', (0, 1), (-1, -1), colors.white),\n                    ('GRID', (0, 0), (-1, -1), 1, colors.black)\n                ]))\n                \n                elements.append(teacher_table)\n                elements.append(Spacer(1, 20))\n            \n            doc.build(elements)\n            \n            logging.info(f\"PDF detalhado exportado: {filepath}\")\n            return filepath\n            \n        except Exception as e:\n            logging.error(f\"Erro ao exportar PDF detalhado: {e}\")\n            raise\n    \n    def export_excel(self, teachers, school):\n        \"\"\"Exporta para Excel usando openpyxl\"\"\"\n        try:\n            from openpyxl import Workbook\n            from openpyxl.styles import Font, PatternFill, Alignment\n            \n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"professores_{school.replace(' ', '_')}_{timestamp}.xlsx\"\n            filepath = os.path.join(self.exports_dir, filename)\n            \n            wb = Workbook()\n            ws = wb.active\n            ws.title = \"Professores\"\n            \n            # Cabeçalhos\n            headers = [\n                'SIAPE', 'Nome', 'CPF', 'Data Nascimento', 'Sexo', 'Estado Civil',\n                'Carga Horária', 'Carreira', 'Data Ingresso', 'Status', 'Área Atuação',\n                'Pós-graduação', 'Graduação', 'Instituição Graduação',\n                'Curso Pós', 'Instituição Pós', 'Email', 'Telefone'\n            ]\n            \n            # Estilo do cabeçalho\n            header_font = Font(bold=True, color=\"FFFFFF\")\n            header_fill = PatternFill(start_color=\"366092\", end_color=\"366092\", fill_type=\"solid\")\n            header_alignment = Alignment(horizontal=\"center\", vertical=\"center\")\n            \n            # Adiciona cabeçalhos\n            for col, header in enumerate(headers, 1):\n                cell = ws.cell(row=1, column=col, value=header)\n                cell.font = header_font\n                cell.fill = header_fill\n                cell.alignment = header_alignment\n            \n            # Adiciona dados\n            for row, teacher in enumerate(teachers, 2):\n                ws.cell(row=row, column=1, value=teacher.get('siape', ''))\n                ws.cell(row=row, column=2, value=teacher.get('nome', ''))\n                ws.cell(row=row, column=3, value=teacher.get('cpf', ''))\n                ws.cell(row=row, column=4, value=teacher.get('data_nascimento', ''))\n                ws.cell(row=row, column=5, value=teacher.get('sexo', ''))\n                ws.cell(row=row, column=6, value=teacher.get('estado_civil', ''))\n                ws.cell(row=row, column=7, value=teacher.get('carga_horaria', ''))\n                ws.cell(row=row, column=8, value=teacher.get('carreira', ''))\n                ws.cell(row=row, column=9, value=teacher.get('data_ingresso', ''))\n                ws.cell(row=row, column=10, value=teacher.get('status', 'Ativo'))\n                ws.cell(row=row, column=11, value=teacher.get('area_atuacao', ''))\n                ws.cell(row=row, column=12, value=teacher.get('pos_graduacao', ''))\n                ws.cell(row=row, column=13, value=teacher.get('graduacao', ''))\n                ws.cell(row=row, column=14, value=teacher.get('instituicao_graduacao', ''))\n                ws.cell(row=row, column=15, value=teacher.get('curso_pos', ''))\n                ws.cell(row=row, column=16, value=teacher.get('instituicao_pos', ''))\n                ws.cell(row=row, column=17, value=teacher.get('email', ''))\n                ws.cell(row=row, column=18, value=teacher.get('telefone', ''))\n            \n            # Ajusta largura das colunas\n            for column in ws.columns:\n                max_length = 0\n                column_letter = column[0].column_letter\n                \n                for cell in column:\n                    try:\n                        if len(str(cell.value)) > max_length:\n                            max_length = len(str(cell.value))\n                    except:\n                        pass\n                \n                adjusted_width = min(max_length + 2, 50)\n                ws.column_dimensions[column_letter].width = adjusted_width\n            \n            # Salva arquivo\n            wb.save(filepath)\n            \n            logging.info(f\"Excel exportado: {filepath}\")\n            return filepath\n            \n        except ImportError:\n            logging.warning(\"openpyxl não disponível, usando CSV como alternativa\")\n            return self.export_csv(teachers, school)\n        except Exception as e:\n            logging.error(f\"Erro ao exportar Excel: {e}\")\n            raise\n","size_bytes":18739},"core/teacher_manager.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nGerenciador de Professores - Sistema DIRENS\n\"\"\"\n\nimport logging\nfrom datetime import datetime\nimport json\nimport os\n\nfrom dados.data_manager import DataManager\nfrom dados.history_manager import HistoryManager\nfrom core.validators import ValidatorManager\n\nclass TeacherManager:\n    \"\"\"Gerenciador de operações com professores\"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa o gerenciador\"\"\"\n        self.data_manager = DataManager()\n        self.history_manager = HistoryManager()\n        self.validator = ValidatorManager()\n    \n    def create_teacher(self, teacher_data, user):\n        \"\"\"Cria um novo professor\"\"\"\n        try:\n            # Valida dados\n            validation_result = self.validator.validate_teacher_data(teacher_data)\n            if not validation_result['valid']:\n                logging.error(f\"Dados inválidos: {validation_result['errors']}\")\n                return False\n            \n            # Verifica se SIAPE já existe\n            if self.teacher_exists(teacher_data['siape'], teacher_data['escola']):\n                logging.error(f\"SIAPE já existe: {teacher_data['siape']}\")\n                return False\n            \n            # Adiciona metadados\n            teacher_data['data_criacao'] = datetime.now().isoformat()\n            teacher_data['data_atualizacao'] = datetime.now().isoformat()\n            teacher_data['criado_por'] = user\n            \n            # Salva no data manager\n            success = self.data_manager.save_teacher(teacher_data)\n            \n            if success:\n                # Registra no histórico\n                self.history_manager.add_history_entry({\n                    'siape': teacher_data['siape'],\n                    'escola': teacher_data['escola'],\n                    'action': 'CREATE',\n                    'user': user,\n                    'timestamp': datetime.now().isoformat(),\n                    'field': 'professor',\n                    'old_value': None,\n                    'new_value': 'Novo professor criado',\n                    'notes': f\"Professor {teacher_data['nome']} criado com SIAPE {teacher_data['siape']}\"\n                })\n                \n                logging.info(f\"Professor criado: {teacher_data['siape']} - {teacher_data['nome']}\")\n                return True\n            \n            return False\n            \n        except Exception as e:\n            logging.error(f\"Erro ao criar professor: {e}\")\n            return False\n    \n    def update_teacher(self, teacher_data, school, user):\n        \"\"\"Atualiza dados de um professor\"\"\"\n        try:\n            siape = teacher_data['siape']\n            \n            # Carrega dados atuais\n            current_data = self.data_manager.get_teacher_by_siape(siape, school)\n            if not current_data:\n                logging.error(f\"Professor não encontrado: {siape}\")\n                return False\n            \n            # Valida novos dados\n            validation_result = self.validator.validate_teacher_data(teacher_data)\n            if not validation_result['valid']:\n                logging.error(f\"Dados inválidos: {validation_result['errors']}\")\n                return False\n            \n            # Atualiza metadados\n            teacher_data['data_atualizacao'] = datetime.now().isoformat()\n            teacher_data['atualizado_por'] = user\n            \n            # Preserva dados de criação\n            teacher_data['data_criacao'] = current_data.get('data_criacao')\n            teacher_data['criado_por'] = current_data.get('criado_por')\n            \n            # Identifica alterações\n            changes = self.identify_changes(current_data, teacher_data)\n            \n            # Salva alterações\n            success = self.data_manager.update_teacher(teacher_data)\n            \n            if success:\n                # Registra histórico das alterações\n                for field, (old_value, new_value) in changes.items():\n                    self.history_manager.add_history_entry({\n                        'siape': siape,\n                        'escola': school,\n                        'action': 'UPDATE',\n                        'user': user,\n                        'timestamp': datetime.now().isoformat(),\n                        'field': field,\n                        'old_value': str(old_value) if old_value is not None else '',\n                        'new_value': str(new_value) if new_value is not None else '',\n                        'notes': f\"Campo {field} alterado\"\n                    })\n                \n                logging.info(f\"Professor atualizado: {siape} - {len(changes)} alterações\")\n                return True\n            \n            return False\n            \n        except Exception as e:\n            logging.error(f\"Erro ao atualizar professor: {e}\")\n            return False\n    \n    def delete_teacher(self, siape, school, user):\n        \"\"\"Exclui um professor\"\"\"\n        try:\n            # Verifica se professor existe\n            teacher_data = self.data_manager.get_teacher_by_siape(siape, school)\n            if not teacher_data:\n                logging.error(f\"Professor não encontrado: {siape}\")\n                return False\n            \n            # Marca como excluído em vez de deletar fisicamente\n            teacher_data['status'] = 'Excluído'\n            teacher_data['data_exclusao'] = datetime.now().isoformat()\n            teacher_data['excluido_por'] = user\n            \n            # Atualiza registro\n            success = self.data_manager.update_teacher(teacher_data)\n            \n            if success:\n                # Registra no histórico\n                self.history_manager.add_history_entry({\n                    'siape': siape,\n                    'escola': school,\n                    'action': 'DELETE',\n                    'user': user,\n                    'timestamp': datetime.now().isoformat(),\n                    'field': 'professor',\n                    'old_value': teacher_data['nome'],\n                    'new_value': 'EXCLUÍDO',\n                    'notes': f\"Professor {teacher_data['nome']} excluído\"\n                })\n                \n                logging.info(f\"Professor excluído: {siape} - {teacher_data['nome']}\")\n                return True\n            \n            return False\n            \n        except Exception as e:\n            logging.error(f\"Erro ao excluir professor: {e}\")\n            return False\n    \n    def get_teacher_by_siape(self, siape, school):\n        \"\"\"Busca professor por SIAPE\"\"\"\n        try:\n            return self.data_manager.get_teacher_by_siape(siape, school)\n        except Exception as e:\n            logging.error(f\"Erro ao buscar professor: {e}\")\n            return None\n    \n    def get_teachers_by_school(self, school, include_deleted=False):\n        \"\"\"Lista professores de uma escola\"\"\"\n        try:\n            teachers = self.data_manager.get_teachers_by_school(school)\n            \n            if not include_deleted:\n                # Filtra professores não excluídos\n                teachers = [t for t in teachers if t.get('status') != 'Excluído']\n            \n            return teachers\n            \n        except Exception as e:\n            logging.error(f\"Erro ao listar professores: {e}\")\n            return []\n    \n    def search_teachers(self, school, search_term, filters=None):\n        \"\"\"Busca professores com filtros\"\"\"\n        try:\n            teachers = self.get_teachers_by_school(school)\n            \n            if not teachers:\n                return []\n            \n            # Aplica busca por termo\n            if search_term:\n                search_term = search_term.lower().strip()\n                teachers = [\n                    t for t in teachers\n                    if search_term in t.get('nome', '').lower() or\n                       search_term in t.get('siape', '')\n                ]\n            \n            # Aplica filtros adicionais\n            if filters:\n                if filters.get('pos_graduacao'):\n                    teachers = [t for t in teachers if t.get('pos_graduacao') == filters['pos_graduacao']]\n                \n                if filters.get('carga_horaria'):\n                    teachers = [t for t in teachers if t.get('carga_horaria') == filters['carga_horaria']]\n                \n                if filters.get('carreira'):\n                    teachers = [t for t in teachers if t.get('carreira') == filters['carreira']]\n                \n                if filters.get('status'):\n                    teachers = [t for t in teachers if t.get('status') == filters['status']]\n            \n            return teachers\n            \n        except Exception as e:\n            logging.error(f\"Erro na busca de professores: {e}\")\n            return []\n    \n    def teacher_exists(self, siape, school):\n        \"\"\"Verifica se professor já existe\"\"\"\n        try:\n            teacher = self.data_manager.get_teacher_by_siape(siape, school)\n            return teacher is not None and teacher.get('status') != 'Excluído'\n        except Exception as e:\n            logging.error(f\"Erro ao verificar existência do professor: {e}\")\n            return False\n    \n    def identify_changes(self, old_data, new_data):\n        \"\"\"Identifica alterações entre dados antigos e novos\"\"\"\n        changes = {}\n        \n        # Campos que devem ser monitorados\n        monitored_fields = [\n            'nome', 'cpf', 'data_nascimento', 'sexo', 'estado_civil',\n            'carga_horaria', 'carreira', 'data_ingresso', 'status',\n            'area_atuacao', 'pos_graduacao', 'graduacao', 'instituicao_graduacao',\n            'curso_pos', 'instituicao_pos'\n        ]\n        \n        for field in monitored_fields:\n            old_value = old_data.get(field)\n            new_value = new_data.get(field)\n            \n            # Converte para string para comparação\n            old_str = str(old_value) if old_value is not None else ''\n            new_str = str(new_value) if new_value is not None else ''\n            \n            if old_str != new_str:\n                changes[field] = (old_value, new_value)\n        \n        return changes\n    \n    def get_statistics(self, school):\n        \"\"\"Gera estatísticas dos professores\"\"\"\n        try:\n            teachers = self.get_teachers_by_school(school)\n            \n            if not teachers:\n                return {\n                    'total': 0,\n                    'ativos': 0,\n                    'por_pos_graduacao': {},\n                    'por_carga_horaria': {},\n                    'por_carreira': {},\n                    'por_status': {}\n                }\n            \n            # Contadores\n            total = len(teachers)\n            ativos = len([t for t in teachers if t.get('status', 'Ativo') == 'Ativo'])\n            \n            # Distribuição por categoria\n            from collections import Counter\n            \n            pos_graduacao = Counter([t.get('pos_graduacao', 'Não informado') for t in teachers])\n            carga_horaria = Counter([t.get('carga_horaria', 'Não informado') for t in teachers])\n            carreira = Counter([t.get('carreira', 'Não informado') for t in teachers])\n            status = Counter([t.get('status', 'Ativo') for t in teachers])\n            \n            return {\n                'total': total,\n                'ativos': ativos,\n                'por_pos_graduacao': dict(pos_graduacao),\n                'por_carga_horaria': dict(carga_horaria),\n                'por_carreira': dict(carreira),\n                'por_status': dict(status)\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro ao gerar estatísticas: {e}\")\n            return {}\n    \n    def validate_teacher_consistency(self, school):\n        \"\"\"Valida consistência dos dados dos professores\"\"\"\n        try:\n            teachers = self.get_teachers_by_school(school, include_deleted=True)\n            issues = []\n            \n            for teacher in teachers:\n                teacher_issues = []\n                \n                # Valida dados obrigatórios\n                required_fields = ['siape', 'nome', 'cpf', 'data_nascimento', 'carga_horaria', 'carreira']\n                for field in required_fields:\n                    if not teacher.get(field):\n                        teacher_issues.append(f\"Campo obrigatório ausente: {field}\")\n                \n                # Valida SIAPE\n                siape = teacher.get('siape', '')\n                if not self.validator.validate_siape(siape):\n                    teacher_issues.append(\"SIAPE inválido\")\n                \n                # Valida CPF\n                cpf = teacher.get('cpf', '')\n                if not self.validator.validate_cpf(cpf):\n                    teacher_issues.append(\"CPF inválido\")\n                \n                # Valida datas\n                data_nasc = teacher.get('data_nascimento', '')\n                if data_nasc and not self.validator.validate_date(data_nasc):\n                    teacher_issues.append(\"Data de nascimento inválida\")\n                \n                data_ing = teacher.get('data_ingresso', '')\n                if data_ing and not self.validator.validate_date(data_ing):\n                    teacher_issues.append(\"Data de ingresso inválida\")\n                \n                if teacher_issues:\n                    issues.append({\n                        'siape': siape,\n                        'nome': teacher.get('nome', 'N/A'),\n                        'issues': teacher_issues\n                    })\n            \n            return issues\n            \n        except Exception as e:\n            logging.error(f\"Erro na validação de consistência: {e}\")\n            return []\n    \n    def fix_data_issues(self, school, user):\n        \"\"\"Corrige problemas nos dados automaticamente\"\"\"\n        try:\n            teachers = self.get_teachers_by_school(school, include_deleted=True)\n            fixed_count = 0\n            \n            for teacher in teachers:\n                needs_update = False\n                \n                # Corrige nome em maiúscula\n                if teacher.get('nome'):\n                    nome_upper = teacher['nome'].upper()\n                    if teacher['nome'] != nome_upper:\n                        teacher['nome'] = nome_upper\n                        needs_update = True\n                \n                # Corrige status padrão\n                if not teacher.get('status'):\n                    teacher['status'] = 'Ativo'\n                    needs_update = True\n                \n                # Adiciona metadados se ausentes\n                if not teacher.get('data_criacao'):\n                    teacher['data_criacao'] = datetime.now().isoformat()\n                    needs_update = True\n                \n                if needs_update:\n                    teacher['data_atualizacao'] = datetime.now().isoformat()\n                    teacher['corrigido_por'] = user\n                    \n                    self.data_manager.update_teacher(teacher)\n                    fixed_count += 1\n            \n            logging.info(f\"Correção automática concluída: {fixed_count} registros corrigidos\")\n            return fixed_count\n            \n        except Exception as e:\n            logging.error(f\"Erro na correção automática: {e}\")\n            return 0\n","size_bytes":15382},"core/validators.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nMódulo de Validadores - Sistema DIRENS\n\"\"\"\n\nimport re\nfrom datetime import datetime\nimport logging\n\nfrom recursos.constants import CARGAS_HORARIAS, CARREIRAS, POS_GRADUACAO\n\nclass ValidatorManager:\n    \"\"\"Gerenciador de validações\"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa o validador\"\"\"\n        self.cpf_pattern = re.compile(r'^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$')\n        self.siape_pattern = re.compile(r'^\\d{7}$')\n        self.date_pattern = re.compile(r'^\\d{2}-\\d{2}-\\d{4}$')\n    \n    def validate_siape(self, siape):\n        \"\"\"Valida SIAPE (7 dígitos)\"\"\"\n        if not siape:\n            return False\n        \n        # Remove espaços e caracteres não numéricos\n        siape_clean = re.sub(r'\\D', '', str(siape))\n        \n        # Deve ter exatamente 7 dígitos\n        return len(siape_clean) == 7 and siape_clean.isdigit()\n    \n    def validate_cpf(self, cpf):\n        \"\"\"Valida CPF brasileiro\"\"\"\n        if not cpf:\n            return False\n        \n        # Remove pontos, hífens e espaços\n        cpf_clean = re.sub(r'[^\\d]', '', str(cpf))\n        \n        # Deve ter 11 dígitos\n        if len(cpf_clean) != 11:\n            return False\n        \n        # Verifica se não são todos dígitos iguais\n        if cpf_clean == cpf_clean[0] * 11:\n            return False\n        \n        # Calcula primeiro dígito verificador\n        sum1 = sum(int(cpf_clean[i]) * (10 - i) for i in range(9))\n        digit1 = 11 - (sum1 % 11)\n        if digit1 > 9:\n            digit1 = 0\n        \n        # Calcula segundo dígito verificador\n        sum2 = sum(int(cpf_clean[i]) * (11 - i) for i in range(10))\n        digit2 = 11 - (sum2 % 11)\n        if digit2 > 9:\n            digit2 = 0\n        \n        # Verifica se os dígitos conferem\n        return cpf_clean[-2:] == f\"{digit1}{digit2}\"\n    \n    def validate_date(self, date_str):\n        \"\"\"Valida data no formato DD-MM-AAAA\"\"\"\n        if not date_str:\n            return False\n        \n        # Verifica formato\n        if not self.date_pattern.match(str(date_str)):\n            return False\n        \n        try:\n            # Tenta converter para data válida\n            day, month, year = map(int, date_str.split('-'))\n            datetime(year, month, day)\n            \n            # Verifica se a data não é muito antiga ou futura\n            current_year = datetime.now().year\n            if year < 1900 or year > current_year + 1:\n                return False\n            \n            return True\n            \n        except ValueError:\n            return False\n    \n    def validate_email(self, email):\n        \"\"\"Valida formato de email\"\"\"\n        if not email:\n            return True  # Email é opcional\n        \n        email_pattern = re.compile(\n            r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        )\n        return email_pattern.match(email.strip()) is not None\n    \n    def validate_phone(self, phone):\n        \"\"\"Valida telefone brasileiro\"\"\"\n        if not phone:\n            return True  # Telefone é opcional\n        \n        # Remove caracteres não numéricos\n        phone_clean = re.sub(r'\\D', '', str(phone))\n        \n        # Aceita formatos: 10 dígitos (fixo) ou 11 dígitos (celular)\n        return len(phone_clean) in [10, 11]\n    \n    def validate_required_fields(self, data):\n        \"\"\"Valida campos obrigatórios\"\"\"\n        required_fields = [\n            'siape', 'nome', 'cpf', 'data_nascimento', 'sexo',\n            'carga_horaria', 'carreira', 'data_ingresso', 'pos_graduacao'\n        ]\n        \n        missing_fields = []\n        \n        for field in required_fields:\n            value = data.get(field)\n            if not value or str(value).strip() == '':\n                missing_fields.append(field)\n        \n        return missing_fields\n    \n    def validate_restricted_values(self, data):\n        \"\"\"Valida valores restritos (listas fechadas)\"\"\"\n        errors = []\n        \n        # Valida carga horária\n        carga = data.get('carga_horaria')\n        if carga and carga not in CARGAS_HORARIAS:\n            errors.append(f\"Carga horária inválida: {carga}\")\n        \n        # Valida carreira\n        carreira = data.get('carreira')\n        if carreira and carreira not in CARREIRAS:\n            errors.append(f\"Carreira inválida: {carreira}\")\n        \n        # Valida pós-graduação\n        pos = data.get('pos_graduacao')\n        if pos and pos not in POS_GRADUACAO:\n            errors.append(f\"Pós-graduação inválida: {pos}\")\n        \n        # Valida sexo\n        sexo = data.get('sexo')\n        if sexo and sexo not in ['M', 'F']:\n            errors.append(f\"Sexo deve ser 'M' ou 'F'\")\n        \n        return errors\n    \n    def validate_business_rules(self, data):\n        \"\"\"Valida regras de negócio específicas\"\"\"\n        errors = []\n        \n        # Valida idade mínima (18 anos)\n        data_nasc = data.get('data_nascimento')\n        if data_nasc and self.validate_date(data_nasc):\n            try:\n                day, month, year = map(int, data_nasc.split('-'))\n                birth_date = datetime(year, month, day)\n                age = (datetime.now() - birth_date).days / 365.25\n                \n                if age < 18:\n                    errors.append(\"Professor deve ter pelo menos 18 anos\")\n                elif age > 80:\n                    errors.append(\"Verifique a data de nascimento (idade muito alta)\")\n                    \n            except Exception:\n                pass\n        \n        # Valida data de ingresso não pode ser futura\n        data_ing = data.get('data_ingresso')\n        if data_ing and self.validate_date(data_ing):\n            try:\n                day, month, year = map(int, data_ing.split('-'))\n                ingresso_date = datetime(year, month, day)\n                \n                if ingresso_date > datetime.now():\n                    errors.append(\"Data de ingresso não pode ser futura\")\n                    \n                # Data de ingresso deve ser posterior ao nascimento + 18 anos\n                if data_nasc and self.validate_date(data_nasc):\n                    day_nasc, month_nasc, year_nasc = map(int, data_nasc.split('-'))\n                    birth_date = datetime(year_nasc, month_nasc, day_nasc)\n                    min_ingresso = datetime(year_nasc + 18, month_nasc, day_nasc)\n                    \n                    if ingresso_date < min_ingresso:\n                        errors.append(\"Data de ingresso deve ser posterior aos 18 anos\")\n                        \n            except Exception:\n                pass\n        \n        # Valida consistência de formação\n        pos_graduacao = data.get('pos_graduacao')\n        graduacao = data.get('graduacao', '').strip()\n        \n        if pos_graduacao in ['ESPECIALIZAÇÃO', 'MESTRADO', 'DOUTORADO'] and not graduacao:\n            errors.append(\"Graduação é obrigatória para pós-graduação\")\n        \n        return errors\n    \n    def validate_teacher_data(self, data):\n        \"\"\"Validação completa dos dados do professor\"\"\"\n        all_errors = []\n        \n        try:\n            # Campos obrigatórios\n            missing_fields = self.validate_required_fields(data)\n            if missing_fields:\n                all_errors.extend([f\"Campo obrigatório: {field}\" for field in missing_fields])\n            \n            # Se há campos obrigatórios faltando, não continua\n            if missing_fields:\n                return {'valid': False, 'errors': all_errors}\n            \n            # Validações específicas\n            siape = data.get('siape', '').strip()\n            if not self.validate_siape(siape):\n                all_errors.append(\"SIAPE deve ter exatamente 7 dígitos numéricos\")\n            \n            cpf = data.get('cpf', '').strip()\n            if not self.validate_cpf(cpf):\n                all_errors.append(\"CPF inválido\")\n            \n            data_nasc = data.get('data_nascimento', '').strip()\n            if not self.validate_date(data_nasc):\n                all_errors.append(\"Data de nascimento inválida (formato: DD-MM-AAAA)\")\n            \n            data_ing = data.get('data_ingresso', '').strip()\n            if not self.validate_date(data_ing):\n                all_errors.append(\"Data de ingresso inválida (formato: DD-MM-AAAA)\")\n            \n            # Validações de email e telefone (opcionais)\n            email = data.get('email', '').strip()\n            if email and not self.validate_email(email):\n                all_errors.append(\"Email inválido\")\n            \n            telefone = data.get('telefone', '').strip()\n            if telefone and not self.validate_phone(telefone):\n                all_errors.append(\"Telefone inválido\")\n            \n            # Valores restritos\n            restricted_errors = self.validate_restricted_values(data)\n            all_errors.extend(restricted_errors)\n            \n            # Regras de negócio\n            business_errors = self.validate_business_rules(data)\n            all_errors.extend(business_errors)\n            \n            # Validações de tamanho\n            nome = data.get('nome', '').strip()\n            if len(nome) < 2:\n                all_errors.append(\"Nome deve ter pelo menos 2 caracteres\")\n            elif len(nome) > 100:\n                all_errors.append(\"Nome muito longo (máximo 100 caracteres)\")\n            \n            # Verifica se nome contém apenas letras e espaços\n            if nome and not re.match(r'^[A-ZÁÀÂÃÉÈÊÍÏÓÔÕÖÚÇÑ\\s]+$', nome):\n                all_errors.append(\"Nome deve conter apenas letras e espaços\")\n            \n            return {\n                'valid': len(all_errors) == 0,\n                'errors': all_errors\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro na validação: {e}\")\n            return {\n                'valid': False,\n                'errors': ['Erro interno na validação dos dados']\n            }\n    \n    def sanitize_teacher_data(self, data):\n        \"\"\"Limpa e padroniza dados do professor\"\"\"\n        cleaned_data = data.copy()\n        \n        try:\n            # Limpa e formata campos de texto\n            text_fields = ['nome', 'graduacao', 'curso_pos', 'area_atuacao', \n                          'instituicao_graduacao', 'instituicao_pos']\n            \n            for field in text_fields:\n                if field in cleaned_data and cleaned_data[field]:\n                    # Remove espaços extras e converte para maiúscula (exceto alguns campos)\n                    value = str(cleaned_data[field]).strip()\n                    if field == 'nome':\n                        cleaned_data[field] = value.upper()\n                    else:\n                        cleaned_data[field] = value\n            \n            # Limpa SIAPE (apenas números)\n            if 'siape' in cleaned_data:\n                siape = re.sub(r'\\D', '', str(cleaned_data['siape']))\n                cleaned_data['siape'] = siape\n            \n            # Formata CPF\n            if 'cpf' in cleaned_data:\n                cpf = re.sub(r'\\D', '', str(cleaned_data['cpf']))\n                if len(cpf) == 11:\n                    cleaned_data['cpf'] = f\"{cpf[:3]}.{cpf[3:6]}.{cpf[6:9]}-{cpf[9:]}\"\n            \n            # Formata telefone\n            if 'telefone' in cleaned_data and cleaned_data['telefone']:\n                phone = re.sub(r'\\D', '', str(cleaned_data['telefone']))\n                if len(phone) == 11:\n                    cleaned_data['telefone'] = f\"({phone[:2]}) {phone[2:7]}-{phone[7:]}\"\n                elif len(phone) == 10:\n                    cleaned_data['telefone'] = f\"({phone[:2]}) {phone[2:6]}-{phone[6:]}\"\n            \n            # Remove campos vazios opcionais\n            optional_fields = ['email', 'telefone', 'estado_civil', 'area_atuacao',\n                             'graduacao', 'instituicao_graduacao', 'curso_pos', 'instituicao_pos']\n            \n            for field in optional_fields:\n                if field in cleaned_data and not str(cleaned_data[field]).strip():\n                    cleaned_data[field] = ''\n            \n            return cleaned_data\n            \n        except Exception as e:\n            logging.error(f\"Erro na limpeza dos dados: {e}\")\n            return data\n","size_bytes":12329},"dados/__init__.py":{"content":"\"\"\"\nMódulo de Dados do Sistema DIRENS\nResponsável pela persistência e gerenciamento de dados\n\"\"\"\n\n__version__ = \"1.0.0\"\n__author__ = \"Sistema DIRENS\"\n\n","size_bytes":154},"dados/data_manager.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nGerenciador de Dados - Sistema DIRENS\n\"\"\"\n\nimport json\nimport os\nimport logging\nfrom datetime import datetime\nimport threading\nfrom filelock import FileLock\n\nclass DataManager:\n    \"\"\"Gerenciador de persistência de dados\"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa o gerenciador de dados\"\"\"\n        self.data_dir = \"data\"\n        self.teachers_file = os.path.join(self.data_dir, \"teachers.json\")\n        self.schools_file = os.path.join(self.data_dir, \"schools.json\")\n        self.lock = threading.Lock()\n        \n        self.ensure_data_directory()\n        self.initialize_data_files()\n    \n    def ensure_data_directory(self):\n        \"\"\"Garante que o diretório de dados existe\"\"\"\n        if not os.path.exists(self.data_dir):\n            os.makedirs(self.data_dir)\n    \n    def initialize_data_files(self):\n        \"\"\"Inicializa arquivos de dados se não existirem\"\"\"\n        # Arquivo de professores\n        if not os.path.exists(self.teachers_file):\n            initial_data = {\n                \"teachers\": {},\n                \"metadata\": {\n                    \"created_at\": datetime.now().isoformat(),\n                    \"version\": \"1.0\"\n                }\n            }\n            self.save_json(self.teachers_file, initial_data)\n        \n        # Arquivo de escolas\n        if not os.path.exists(self.schools_file):\n            from recursos.constants import ESCOLAS\n            schools_data = {\n                \"schools\": ESCOLAS,\n                \"metadata\": {\n                    \"created_at\": datetime.now().isoformat(),\n                    \"version\": \"1.0\"\n                }\n            }\n            self.save_json(self.schools_file, schools_data)\n    \n    def save_json(self, filepath, data):\n        \"\"\"Salva dados em JSON com lock\"\"\"\n        try:\n            # Usa FileLock para evitar conflitos\n            lock_file = filepath + \".lock\"\n            \n            with FileLock(lock_file, timeout=10):\n                with open(filepath, 'w', encoding='utf-8') as f:\n                    json.dump(data, f, indent=2, ensure_ascii=False, default=str)\n                    \n        except Exception as e:\n            if \"FileLock\" in str(type(e)):\n                # Fallback sem FileLock se não estiver disponível\n                with self.lock:\n                    with open(filepath, 'w', encoding='utf-8') as f:\n                        json.dump(data, f, indent=2, ensure_ascii=False, default=str)\n            else:\n                logging.error(f\"Erro ao salvar JSON {filepath}: {e}\")\n                raise\n    \n    def load_json(self, filepath):\n        \"\"\"Carrega dados de JSON com lock\"\"\"\n        try:\n            if not os.path.exists(filepath):\n                return {}\n            \n            # Usa FileLock para evitar conflitos\n            lock_file = filepath + \".lock\"\n            \n            with FileLock(lock_file, timeout=10):\n                with open(filepath, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n                    \n        except Exception as e:\n            if \"FileLock\" in str(type(e)):\n                # Fallback sem FileLock se não estiver disponível\n                with self.lock:\n                    with open(filepath, 'r', encoding='utf-8') as f:\n                        return json.load(f)\n            else:\n                logging.error(f\"Erro ao carregar JSON {filepath}: {e}\")\n                return {}\n    \n    def save_teacher(self, teacher_data):\n        \"\"\"Salva dados de um professor\"\"\"\n        try:\n            # Carrega dados atuais\n            data = self.load_json(self.teachers_file)\n            \n            if \"teachers\" not in data:\n                data[\"teachers\"] = {}\n            \n            school = teacher_data.get('escola', '')\n            siape = teacher_data.get('siape', '')\n            \n            if not school or not siape:\n                logging.error(\"Escola e SIAPE são obrigatórios\")\n                return False\n            \n            # Cria estrutura da escola se não existir\n            if school not in data[\"teachers\"]:\n                data[\"teachers\"][school] = {}\n            \n            # Salva professor\n            data[\"teachers\"][school][siape] = teacher_data\n            \n            # Atualiza metadados\n            data[\"metadata\"][\"last_updated\"] = datetime.now().isoformat()\n            \n            # Salva arquivo\n            self.save_json(self.teachers_file, data)\n            \n            logging.info(f\"Professor salvo: {siape} - {school}\")\n            return True\n            \n        except Exception as e:\n            logging.error(f\"Erro ao salvar professor: {e}\")\n            return False\n    \n    def get_teacher_by_siape(self, siape, school):\n        \"\"\"Busca professor por SIAPE e escola\"\"\"\n        try:\n            data = self.load_json(self.teachers_file)\n            \n            teachers = data.get(\"teachers\", {})\n            school_teachers = teachers.get(school, {})\n            \n            return school_teachers.get(siape)\n            \n        except Exception as e:\n            logging.error(f\"Erro ao buscar professor: {e}\")\n            return None\n    \n    def get_teachers_by_school(self, school):\n        \"\"\"Lista todos os professores de uma escola\"\"\"\n        try:\n            data = self.load_json(self.teachers_file)\n            \n            teachers = data.get(\"teachers\", {})\n            school_teachers = teachers.get(school, {})\n            \n            # Retorna lista de professores\n            return list(school_teachers.values())\n            \n        except Exception as e:\n            logging.error(f\"Erro ao listar professores: {e}\")\n            return []\n    \n    def update_teacher(self, teacher_data):\n        \"\"\"Atualiza dados de um professor\"\"\"\n        try:\n            school = teacher_data.get('escola', '')\n            siape = teacher_data.get('siape', '')\n            \n            if not school or not siape:\n                logging.error(\"Escola e SIAPE são obrigatórios\")\n                return False\n            \n            # Verifica se professor existe\n            existing_teacher = self.get_teacher_by_siape(siape, school)\n            if not existing_teacher:\n                logging.error(f\"Professor não encontrado: {siape} - {school}\")\n                return False\n            \n            # Atualiza dados (reutiliza save_teacher)\n            return self.save_teacher(teacher_data)\n            \n        except Exception as e:\n            logging.error(f\"Erro ao atualizar professor: {e}\")\n            return False\n    \n    def delete_teacher(self, siape, school):\n        \"\"\"Remove um professor (exclusão física)\"\"\"\n        try:\n            data = self.load_json(self.teachers_file)\n            \n            teachers = data.get(\"teachers\", {})\n            \n            if school not in teachers:\n                logging.error(f\"Escola não encontrada: {school}\")\n                return False\n            \n            if siape not in teachers[school]:\n                logging.error(f\"Professor não encontrado: {siape}\")\n                return False\n            \n            # Remove professor\n            del teachers[school][siape]\n            \n            # Atualiza metadados\n            data[\"metadata\"][\"last_updated\"] = datetime.now().isoformat()\n            \n            # Salva arquivo\n            self.save_json(self.teachers_file, data)\n            \n            logging.info(f\"Professor removido: {siape} - {school}\")\n            return True\n            \n        except Exception as e:\n            logging.error(f\"Erro ao remover professor: {e}\")\n            return False\n    \n    def search_teachers(self, school, search_term=None, filters=None):\n        \"\"\"Busca professores com filtros\"\"\"\n        try:\n            teachers = self.get_teachers_by_school(school)\n            \n            if not teachers:\n                return []\n            \n            # Aplica filtros\n            filtered_teachers = teachers\n            \n            # Filtro por termo de busca\n            if search_term:\n                search_term = search_term.lower().strip()\n                filtered_teachers = [\n                    t for t in filtered_teachers\n                    if search_term in t.get('nome', '').lower() or\n                       search_term in t.get('siape', '')\n                ]\n            \n            # Filtros específicos\n            if filters:\n                for field, value in filters.items():\n                    if value and value != \"Todos\":\n                        filtered_teachers = [\n                            t for t in filtered_teachers\n                            if t.get(field) == value\n                        ]\n            \n            return filtered_teachers\n            \n        except Exception as e:\n            logging.error(f\"Erro na busca de professores: {e}\")\n            return []\n    \n    def get_all_teachers(self):\n        \"\"\"Retorna todos os professores de todas as escolas\"\"\"\n        try:\n            data = self.load_json(self.teachers_file)\n            teachers = data.get(\"teachers\", {})\n            \n            all_teachers = []\n            for school, school_teachers in teachers.items():\n                all_teachers.extend(school_teachers.values())\n            \n            return all_teachers\n            \n        except Exception as e:\n            logging.error(f\"Erro ao listar todos os professores: {e}\")\n            return []\n    \n    def get_teachers_count_by_school(self):\n        \"\"\"Retorna contagem de professores por escola\"\"\"\n        try:\n            data = self.load_json(self.teachers_file)\n            teachers = data.get(\"teachers\", {})\n            \n            count_by_school = {}\n            for school, school_teachers in teachers.items():\n                # Conta apenas professores não excluídos\n                active_teachers = [\n                    t for t in school_teachers.values()\n                    if t.get('status') != 'Excluído'\n                ]\n                count_by_school[school] = len(active_teachers)\n            \n            return count_by_school\n            \n        except Exception as e:\n            logging.error(f\"Erro ao contar professores: {e}\")\n            return {}\n    \n    def backup_data(self, backup_path):\n        \"\"\"Cria backup dos dados\"\"\"\n        try:\n            import shutil\n            \n            # Cria diretório de backup se não existir\n            backup_dir = os.path.dirname(backup_path)\n            if not os.path.exists(backup_dir):\n                os.makedirs(backup_dir)\n            \n            # Copia diretório de dados\n            if os.path.exists(self.data_dir):\n                shutil.copytree(self.data_dir, backup_path, dirs_exist_ok=True)\n                logging.info(f\"Backup criado: {backup_path}\")\n                return True\n            \n            return False\n            \n        except Exception as e:\n            logging.error(f\"Erro ao criar backup: {e}\")\n            return False\n    \n    def restore_data(self, backup_path):\n        \"\"\"Restaura dados de um backup\"\"\"\n        try:\n            import shutil\n            \n            if not os.path.exists(backup_path):\n                logging.error(f\"Backup não encontrado: {backup_path}\")\n                return False\n            \n            # Remove dados atuais\n            if os.path.exists(self.data_dir):\n                shutil.rmtree(self.data_dir)\n            \n            # Restaura backup\n            shutil.copytree(backup_path, self.data_dir)\n            \n            logging.info(f\"Dados restaurados de: {backup_path}\")\n            return True\n            \n        except Exception as e:\n            logging.error(f\"Erro ao restaurar dados: {e}\")\n            return False\n    \n    def validate_data_integrity(self):\n        \"\"\"Valida integridade dos dados\"\"\"\n        try:\n            issues = []\n            \n            # Verifica arquivo de professores\n            if not os.path.exists(self.teachers_file):\n                issues.append(\"Arquivo de professores não encontrado\")\n            else:\n                try:\n                    data = self.load_json(self.teachers_file)\n                    if \"teachers\" not in data:\n                        issues.append(\"Estrutura de dados inválida\")\n                except Exception as e:\n                    issues.append(f\"Erro ao ler arquivo de professores: {e}\")\n            \n            # Verifica arquivo de escolas\n            if not os.path.exists(self.schools_file):\n                issues.append(\"Arquivo de escolas não encontrado\")\n            \n            # Verifica consistência dos dados\n            all_teachers = self.get_all_teachers()\n            for teacher in all_teachers:\n                required_fields = ['siape', 'nome', 'escola']\n                for field in required_fields:\n                    if not teacher.get(field):\n                        issues.append(f\"Professor sem {field}: {teacher}\")\n                        break\n            \n            return {\n                'valid': len(issues) == 0,\n                'issues': issues\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro na validação de integridade: {e}\")\n            return {\n                'valid': False,\n                'issues': [f\"Erro na validação: {e}\"]\n            }\n    \n    def get_data_statistics(self):\n        \"\"\"Retorna estatísticas dos dados\"\"\"\n        try:\n            all_teachers = self.get_all_teachers()\n            count_by_school = self.get_teachers_count_by_school()\n            \n            # Tamanho dos arquivos\n            teachers_size = os.path.getsize(self.teachers_file) if os.path.exists(self.teachers_file) else 0\n            schools_size = os.path.getsize(self.schools_file) if os.path.exists(self.schools_file) else 0\n            \n            return {\n                'total_teachers': len(all_teachers),\n                'teachers_by_school': count_by_school,\n                'data_files_size': teachers_size + schools_size,\n                'teachers_file_size': teachers_size,\n                'schools_file_size': schools_size,\n                'last_update': self.get_last_update_time()\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro ao gerar estatísticas: {e}\")\n            return {}\n    \n    def get_last_update_time(self):\n        \"\"\"Retorna último tempo de atualização\"\"\"\n        try:\n            data = self.load_json(self.teachers_file)\n            return data.get(\"metadata\", {}).get(\"last_updated\")\n        except Exception:\n            return None\n","size_bytes":14619},"dados/history_manager.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nGerenciador de Histórico - Sistema DIRENS\n\"\"\"\n\nimport json\nimport os\nimport logging\nfrom datetime import datetime\nimport threading\nfrom typing import List, Dict, Any, Optional\n\nclass HistoryManager:\n    \"\"\"Gerenciador do histórico de alterações dos professores\"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa o gerenciador de histórico\"\"\"\n        self.data_dir = \"data\"\n        self.history_dir = os.path.join(self.data_dir, \"history\")\n        self.history_index_file = os.path.join(self.history_dir, \"history_index.json\")\n        self.lock = threading.Lock()\n        \n        self.ensure_history_directory()\n        self.initialize_history_index()\n    \n    def ensure_history_directory(self):\n        \"\"\"Garante que o diretório de histórico existe\"\"\"\n        if not os.path.exists(self.history_dir):\n            os.makedirs(self.history_dir)\n    \n    def initialize_history_index(self):\n        \"\"\"Inicializa o arquivo de índice do histórico\"\"\"\n        if not os.path.exists(self.history_index_file):\n            initial_index = {\n                \"metadata\": {\n                    \"created_at\": datetime.now().isoformat(),\n                    \"version\": \"1.0\"\n                },\n                \"teachers\": {}\n            }\n            self.save_json(self.history_index_file, initial_index)\n    \n    def save_json(self, filepath: str, data: Dict[str, Any]) -> None:\n        \"\"\"Salva dados em JSON com lock\"\"\"\n        try:\n            with self.lock:\n                with open(filepath, 'w', encoding='utf-8') as f:\n                    json.dump(data, f, indent=2, ensure_ascii=False, default=str)\n        except Exception as e:\n            logging.error(f\"Erro ao salvar JSON {filepath}: {e}\")\n            raise\n    \n    def load_json(self, filepath: str) -> Dict[str, Any]:\n        \"\"\"Carrega dados de JSON com lock\"\"\"\n        try:\n            if not os.path.exists(filepath):\n                return {}\n            \n            with self.lock:\n                with open(filepath, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n        except Exception as e:\n            logging.error(f\"Erro ao carregar JSON {filepath}: {e}\")\n            return {}\n    \n    def get_teacher_history_file(self, siape: str, school: str) -> str:\n        \"\"\"Retorna o caminho do arquivo de histórico de um professor\"\"\"\n        school_safe = school.replace(\" \", \"_\").replace(\"/\", \"_\").lower()\n        filename = f\"history_{school_safe}_{siape}.json\"\n        return os.path.join(self.history_dir, filename)\n    \n    def add_history_entry(self, entry: Dict[str, Any]) -> bool:\n        \"\"\"Adiciona uma entrada no histórico\"\"\"\n        try:\n            siape = entry.get('siape')\n            school = entry.get('escola')\n            \n            if not siape or not school:\n                logging.error(\"SIAPE e escola são obrigatórios para o histórico\")\n                return False\n            \n            # Adiciona timestamp se não existir\n            if 'timestamp' not in entry:\n                entry['timestamp'] = datetime.now().isoformat()\n            \n            # Arquivo de histórico do professor\n            history_file = self.get_teacher_history_file(siape, school)\n            \n            # Carrega histórico existente\n            if os.path.exists(history_file):\n                history_data = self.load_json(history_file)\n            else:\n                history_data = {\n                    \"siape\": siape,\n                    \"escola\": school,\n                    \"created_at\": datetime.now().isoformat(),\n                    \"entries\": []\n                }\n            \n            # Adiciona nova entrada\n            history_data[\"entries\"].append(entry)\n            history_data[\"last_updated\"] = datetime.now().isoformat()\n            \n            # Salva arquivo de histórico\n            self.save_json(history_file, history_data)\n            \n            # Atualiza índice\n            self.update_history_index(siape, school, history_file)\n            \n            logging.info(f\"Entrada de histórico adicionada: {siape} - {entry.get('action', 'N/A')}\")\n            return True\n            \n        except Exception as e:\n            logging.error(f\"Erro ao adicionar entrada no histórico: {e}\")\n            return False\n    \n    def update_history_index(self, siape: str, school: str, history_file: str) -> None:\n        \"\"\"Atualiza o índice de histórico\"\"\"\n        try:\n            index_data = self.load_json(self.history_index_file)\n            \n            if \"teachers\" not in index_data:\n                index_data[\"teachers\"] = {}\n            \n            # Chave única para o professor\n            teacher_key = f\"{school}_{siape}\"\n            \n            index_data[\"teachers\"][teacher_key] = {\n                \"siape\": siape,\n                \"escola\": school,\n                \"history_file\": history_file,\n                \"last_updated\": datetime.now().isoformat()\n            }\n            \n            index_data[\"metadata\"][\"last_updated\"] = datetime.now().isoformat()\n            \n            self.save_json(self.history_index_file, index_data)\n            \n        except Exception as e:\n            logging.error(f\"Erro ao atualizar índice do histórico: {e}\")\n    \n    def get_teacher_history(self, siape: str, school: str) -> List[Dict[str, Any]]:\n        \"\"\"Retorna o histórico de um professor\"\"\"\n        try:\n            history_file = self.get_teacher_history_file(siape, school)\n            \n            if not os.path.exists(history_file):\n                logging.info(f\"Nenhum histórico encontrado para: {siape} - {school}\")\n                return []\n            \n            history_data = self.load_json(history_file)\n            entries = history_data.get(\"entries\", [])\n            \n            # Ordena por timestamp (mais recente primeiro)\n            entries.sort(key=lambda x: x.get('timestamp', ''), reverse=True)\n            \n            return entries\n            \n        except Exception as e:\n            logging.error(f\"Erro ao buscar histórico do professor: {e}\")\n            return []\n    \n    def get_recent_history(self, school: Optional[str] = None, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"Retorna histórico recente de todos os professores ou de uma escola\"\"\"\n        try:\n            all_entries = []\n            index_data = self.load_json(self.history_index_file)\n            teachers = index_data.get(\"teachers\", {})\n            \n            for teacher_key, teacher_info in teachers.items():\n                # Filtra por escola se especificada\n                if school and teacher_info.get(\"escola\") != school:\n                    continue\n                \n                history_file = teacher_info.get(\"history_file\")\n                if history_file and os.path.exists(history_file):\n                    history_data = self.load_json(history_file)\n                    entries = history_data.get(\"entries\", [])\n                    \n                    # Adiciona informações do professor a cada entrada\n                    for entry in entries:\n                        entry_with_info = entry.copy()\n                        entry_with_info[\"teacher_siape\"] = teacher_info.get(\"siape\")\n                        entry_with_info[\"teacher_escola\"] = teacher_info.get(\"escola\")\n                        all_entries.append(entry_with_info)\n            \n            # Ordena por timestamp (mais recente primeiro)\n            all_entries.sort(key=lambda x: x.get('timestamp', ''), reverse=True)\n            \n            # Limita resultado\n            return all_entries[:limit]\n            \n        except Exception as e:\n            logging.error(f\"Erro ao buscar histórico recente: {e}\")\n            return []\n    \n    def get_history_by_action(self, action: str, school: Optional[str] = None) -> List[Dict[str, Any]]:\n        \"\"\"Retorna histórico filtrado por tipo de ação\"\"\"\n        try:\n            recent_history = self.get_recent_history(school, limit=1000)\n            return [entry for entry in recent_history if entry.get('action') == action]\n            \n        except Exception as e:\n            logging.error(f\"Erro ao buscar histórico por ação: {e}\")\n            return []\n    \n    def get_history_by_user(self, user: str, school: Optional[str] = None) -> List[Dict[str, Any]]:\n        \"\"\"Retorna histórico filtrado por usuário\"\"\"\n        try:\n            recent_history = self.get_recent_history(school, limit=1000)\n            return [entry for entry in recent_history if entry.get('user') == user]\n            \n        except Exception as e:\n            logging.error(f\"Erro ao buscar histórico por usuário: {e}\")\n            return []\n    \n    def get_history_by_date_range(self, start_date: str, end_date: str, school: Optional[str] = None) -> List[Dict[str, Any]]:\n        \"\"\"Retorna histórico em um período específico\"\"\"\n        try:\n            recent_history = self.get_recent_history(school, limit=1000)\n            filtered_entries = []\n            \n            for entry in recent_history:\n                entry_date = entry.get('timestamp', '')\n                if start_date <= entry_date <= end_date:\n                    filtered_entries.append(entry)\n            \n            return filtered_entries\n            \n        except Exception as e:\n            logging.error(f\"Erro ao buscar histórico por período: {e}\")\n            return []\n    \n    def delete_teacher_history(self, siape: str, school: str) -> bool:\n        \"\"\"Remove todo o histórico de um professor\"\"\"\n        try:\n            history_file = self.get_teacher_history_file(siape, school)\n            \n            # Remove arquivo de histórico\n            if os.path.exists(history_file):\n                os.remove(history_file)\n                logging.info(f\"Arquivo de histórico removido: {history_file}\")\n            \n            # Remove do índice\n            index_data = self.load_json(self.history_index_file)\n            teachers = index_data.get(\"teachers\", {})\n            teacher_key = f\"{school}_{siape}\"\n            \n            if teacher_key in teachers:\n                del teachers[teacher_key]\n                index_data[\"metadata\"][\"last_updated\"] = datetime.now().isoformat()\n                self.save_json(self.history_index_file, index_data)\n                logging.info(f\"Professor removido do índice de histórico: {siape} - {school}\")\n            \n            return True\n            \n        except Exception as e:\n            logging.error(f\"Erro ao remover histórico do professor: {e}\")\n            return False\n    \n    def get_history_statistics(self, school: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"Retorna estatísticas do histórico\"\"\"\n        try:\n            recent_history = self.get_recent_history(school, limit=10000)\n            \n            if not recent_history:\n                return {\n                    \"total_entries\": 0,\n                    \"actions_count\": {},\n                    \"users_count\": {},\n                    \"first_entry\": None,\n                    \"last_entry\": None\n                }\n            \n            # Conta ações\n            actions_count = {}\n            users_count = {}\n            \n            for entry in recent_history:\n                action = entry.get('action', 'Unknown')\n                user = entry.get('user', 'Unknown')\n                \n                actions_count[action] = actions_count.get(action, 0) + 1\n                users_count[user] = users_count.get(user, 0) + 1\n            \n            # Primeira e última entrada\n            sorted_entries = sorted(recent_history, key=lambda x: x.get('timestamp', ''))\n            first_entry = sorted_entries[0].get('timestamp') if sorted_entries else None\n            last_entry = sorted_entries[-1].get('timestamp') if sorted_entries else None\n            \n            return {\n                \"total_entries\": len(recent_history),\n                \"actions_count\": actions_count,\n                \"users_count\": users_count,\n                \"first_entry\": first_entry,\n                \"last_entry\": last_entry,\n                \"school\": school\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro ao gerar estatísticas do histórico: {e}\")\n            return {}\n    \n    def cleanup_old_history(self, days_to_keep: int = 365) -> int:\n        \"\"\"Remove entradas de histórico antigas\"\"\"\n        try:\n            cutoff_date = datetime.now() - timedelta(days=days_to_keep)\n            cutoff_iso = cutoff_date.isoformat()\n            \n            cleaned_count = 0\n            index_data = self.load_json(self.history_index_file)\n            teachers = index_data.get(\"teachers\", {})\n            \n            for teacher_key, teacher_info in teachers.items():\n                history_file = teacher_info.get(\"history_file\")\n                \n                if not history_file or not os.path.exists(history_file):\n                    continue\n                \n                history_data = self.load_json(history_file)\n                entries = history_data.get(\"entries\", [])\n                \n                # Filtra entradas recentes\n                recent_entries = [\n                    entry for entry in entries\n                    if entry.get('timestamp', '') >= cutoff_iso\n                ]\n                \n                # Se removeu alguma entrada\n                if len(recent_entries) < len(entries):\n                    history_data[\"entries\"] = recent_entries\n                    history_data[\"last_cleanup\"] = datetime.now().isoformat()\n                    \n                    self.save_json(history_file, history_data)\n                    cleaned_count += len(entries) - len(recent_entries)\n            \n            logging.info(f\"Limpeza de histórico concluída: {cleaned_count} entradas removidas\")\n            return cleaned_count\n            \n        except Exception as e:\n            logging.error(f\"Erro na limpeza do histórico: {e}\")\n            return 0\n    \n    def export_history(self, siape: str, school: str, format: str = 'json') -> Optional[str]:\n        \"\"\"Exporta histórico de um professor\"\"\"\n        try:\n            history = self.get_teacher_history(siape, school)\n            \n            if not history:\n                return None\n            \n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            \n            if format.lower() == 'json':\n                filename = f\"history_{school.replace(' ', '_')}_{siape}_{timestamp}.json\"\n                filepath = os.path.join(\"exports\", filename)\n                \n                # Garante que o diretório existe\n                os.makedirs(\"exports\", exist_ok=True)\n                \n                export_data = {\n                    \"siape\": siape,\n                    \"escola\": school,\n                    \"exported_at\": datetime.now().isoformat(),\n                    \"total_entries\": len(history),\n                    \"history\": history\n                }\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    json.dump(export_data, f, indent=2, ensure_ascii=False, default=str)\n                \n                return filepath\n            \n            elif format.lower() == 'csv':\n                import csv\n                \n                filename = f\"history_{school.replace(' ', '_')}_{siape}_{timestamp}.csv\"\n                filepath = os.path.join(\"exports\", filename)\n                \n                # Garante que o diretório existe\n                os.makedirs(\"exports\", exist_ok=True)\n                \n                with open(filepath, 'w', newline='', encoding='utf-8-sig') as csvfile:\n                    fieldnames = ['timestamp', 'action', 'user', 'field', 'old_value', 'new_value', 'notes']\n                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n                    \n                    writer.writeheader()\n                    for entry in history:\n                        writer.writerow({\n                            'timestamp': entry.get('timestamp', ''),\n                            'action': entry.get('action', ''),\n                            'user': entry.get('user', ''),\n                            'field': entry.get('field', ''),\n                            'old_value': entry.get('old_value', ''),\n                            'new_value': entry.get('new_value', ''),\n                            'notes': entry.get('notes', '')\n                        })\n                \n                return filepath\n            \n            return None\n            \n        except Exception as e:\n            logging.error(f\"Erro ao exportar histórico: {e}\")\n            return None\n    \n    def validate_history_integrity(self) -> Dict[str, Any]:\n        \"\"\"Valida a integridade dos arquivos de histórico\"\"\"\n        try:\n            issues = []\n            fixed_issues = []\n            \n            # Verifica índice principal\n            if not os.path.exists(self.history_index_file):\n                issues.append(\"Arquivo de índice de histórico não encontrado\")\n                self.initialize_history_index()\n                fixed_issues.append(\"Arquivo de índice recriado\")\n            \n            # Verifica cada arquivo de histórico referenciado no índice\n            index_data = self.load_json(self.history_index_file)\n            teachers = index_data.get(\"teachers\", {})\n            \n            for teacher_key, teacher_info in teachers.items():\n                history_file = teacher_info.get(\"history_file\")\n                \n                if not history_file:\n                    issues.append(f\"Arquivo de histórico não especificado para {teacher_key}\")\n                    continue\n                \n                if not os.path.exists(history_file):\n                    issues.append(f\"Arquivo de histórico não encontrado: {history_file}\")\n                    continue\n                \n                try:\n                    history_data = self.load_json(history_file)\n                    \n                    if \"entries\" not in history_data:\n                        issues.append(f\"Estrutura inválida no arquivo: {history_file}\")\n                    \n                    entries = history_data.get(\"entries\", [])\n                    for i, entry in enumerate(entries):\n                        required_fields = ['timestamp', 'action']\n                        for field in required_fields:\n                            if field not in entry:\n                                issues.append(f\"Campo {field} ausente na entrada {i} de {history_file}\")\n                \n                except Exception as e:\n                    issues.append(f\"Erro ao ler arquivo {history_file}: {e}\")\n            \n            return {\n                'valid': len(issues) == 0,\n                'issues': issues,\n                'fixed_issues': fixed_issues,\n                'total_teachers_with_history': len(teachers)\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro na validação da integridade do histórico: {e}\")\n            return {\n                'valid': False,\n                'issues': [f\"Erro na validação: {e}\"],\n                'fixed_issues': [],\n                'total_teachers_with_history': 0\n            }\n","size_bytes":19358},"interface/__init__.py":{"content":"\"\"\"\nMódulo de interfaces gráficas do Sistema DIRENS\n\"\"\"\n\n__version__ = \"1.0.0\"\n__author__ = \"Sistema DIRENS\"\n","size_bytes":111},"interface/backup_window.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nJanela de Gerenciamento de Backups - Sistema DIRENS\n\"\"\"\n\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nfrom datetime import datetime\nimport os\nimport logging\n\nfrom core.backup_manager import BackupManager\n\nclass BackupWindow:\n    \"\"\"Janela para gerenciamento de backups\"\"\"\n    \n    def __init__(self, parent, callback=None):\n        \"\"\"Inicializa a janela de backups\"\"\"\n        self.parent = parent\n        self.callback = callback\n        self.backup_manager = BackupManager()\n        \n        # Cria a janela\n        self.window = tk.Toplevel(parent)\n        self.window.title(\"Gerenciamento de Backups\")\n        self.window.geometry(\"800x600\")\n        self.window.resizable(True, True)\n        \n        # Modal\n        self.window.grab_set()\n        self.window.focus_set()\n        \n        # Centraliza\n        self.center_window()\n        \n        # Cria a interface\n        self.create_widgets()\n        \n        # Carrega dados\n        self.load_backups()\n    \n    def center_window(self):\n        \"\"\"Centraliza a janela\"\"\"\n        self.window.update_idletasks()\n        \n        parent_x = self.parent.winfo_x()\n        parent_y = self.parent.winfo_y()\n        parent_width = self.parent.winfo_width()\n        parent_height = self.parent.winfo_height()\n        \n        width = 800\n        height = 600\n        \n        x = parent_x + (parent_width - width) // 2\n        y = parent_y + (parent_height - height) // 2\n        \n        self.window.geometry(f\"{width}x{height}+{x}+{y}\")\n    \n    def create_widgets(self):\n        \"\"\"Cria os widgets da interface\"\"\"\n        # Frame principal\n        main_frame = ttk.Frame(self.window, padding=\"10\")\n        main_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Título e controles\n        header_frame = ttk.Frame(main_frame)\n        header_frame.pack(fill=tk.X, pady=(0, 10))\n        \n        ttk.Label(\n            header_frame,\n            text=\"Gerenciamento de Backups\",\n            font=(\"Arial\", 14, \"bold\")\n        ).pack(side=tk.LEFT)\n        \n        # Botões de ação\n        button_header_frame = ttk.Frame(header_frame)\n        button_header_frame.pack(side=tk.RIGHT)\n        \n        ttk.Button(\n            button_header_frame,\n            text=\"Criar Backup\",\n            command=self.create_backup\n        ).pack(side=tk.LEFT, padx=2)\n        \n        ttk.Button(\n            button_header_frame,\n            text=\"Atualizar\",\n            command=self.load_backups\n        ).pack(side=tk.LEFT, padx=2)\n        \n        # Frame da lista\n        list_frame = ttk.LabelFrame(main_frame, text=\"Backups Disponíveis\", padding=\"10\")\n        list_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))\n        \n        # Treeview\n        columns = (\"Nome\", \"Data/Hora\", \"Tamanho\", \"Tipo\", \"Status\")\n        \n        self.tree = ttk.Treeview(list_frame, columns=columns, show=\"headings\", height=12)\n        \n        # Configurar colunas\n        column_widths = {\n            \"Nome\": 200,\n            \"Data/Hora\": 140,\n            \"Tamanho\": 100,\n            \"Tipo\": 100,\n            \"Status\": 100\n        }\n        \n        for col in columns:\n            self.tree.heading(col, text=col)\n            self.tree.column(col, width=column_widths.get(col, 100), minwidth=50)\n        \n        # Scrollbars\n        v_scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.tree.yview)\n        h_scrollbar = ttk.Scrollbar(list_frame, orient=tk.HORIZONTAL, command=self.tree.xview)\n        \n        self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)\n        \n        # Grid layout\n        self.tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\n        v_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))\n        h_scrollbar.grid(row=1, column=0, sticky=(tk.W, tk.E))\n        \n        list_frame.grid_rowconfigure(0, weight=1)\n        list_frame.grid_columnconfigure(0, weight=1)\n        \n        # Frame de informações\n        info_frame = ttk.LabelFrame(main_frame, text=\"Informações do Backup\", padding=\"10\")\n        info_frame.pack(fill=tk.X, pady=(0, 10))\n        \n        self.info_text = tk.Text(info_frame, height=4, wrap=tk.WORD)\n        info_scroll = ttk.Scrollbar(info_frame, orient=tk.VERTICAL, command=self.info_text.yview)\n        self.info_text.configure(yscrollcommand=info_scroll.set)\n        \n        self.info_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        info_scroll.pack(side=tk.RIGHT, fill=tk.Y)\n        \n        # Evento de seleção\n        self.tree.bind('<<TreeviewSelect>>', self.on_selection_change)\n        \n        # Frame de ações\n        action_frame = ttk.Frame(main_frame)\n        action_frame.pack(fill=tk.X)\n        \n        # Botões de ação\n        ttk.Button(\n            action_frame,\n            text=\"Restaurar\",\n            command=self.restore_backup\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            action_frame,\n            text=\"Excluir\",\n            command=self.delete_backup\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            action_frame,\n            text=\"Exportar\",\n            command=self.export_backup\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Configurações de backup automático\n        ttk.Separator(action_frame, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=10)\n        \n        self.auto_backup_var = tk.BooleanVar()\n        ttk.Checkbutton(\n            action_frame,\n            text=\"Backup automático\",\n            variable=self.auto_backup_var,\n            command=self.toggle_auto_backup\n        ).pack(side=tk.LEFT, padx=10)\n        \n        # Botão fechar\n        ttk.Button(\n            action_frame,\n            text=\"Fechar\",\n            command=self.window.destroy\n        ).pack(side=tk.RIGHT, padx=5)\n        \n        # Carrega configuração de backup automático\n        self.auto_backup_var.set(self.backup_manager.is_auto_backup_enabled())\n    \n    def load_backups(self):\n        \"\"\"Carrega a lista de backups\"\"\"\n        try:\n            # Limpa a lista\n            for item in self.tree.get_children():\n                self.tree.delete(item)\n            \n            # Carrega backups\n            backups = self.backup_manager.list_backups()\n            \n            if not backups:\n                self.tree.insert('', tk.END, values=(\n                    \"Nenhum backup encontrado\", \"\", \"\", \"\", \"\"\n                ))\n                return\n            \n            # Ordena por data (mais recente primeiro)\n            backups.sort(key=lambda x: x.get('timestamp', ''), reverse=True)\n            \n            # Adiciona à lista\n            for backup in backups:\n                timestamp = backup.get('timestamp', '')\n                if timestamp:\n                    try:\n                        dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))\n                        formatted_date = dt.strftime('%d/%m/%Y %H:%M')\n                    except:\n                        formatted_date = timestamp\n                else:\n                    formatted_date = ''\n                \n                # Calcula tamanho do arquivo\n                filepath = backup.get('filepath', '')\n                size_str = ''\n                if filepath and os.path.exists(filepath):\n                    size_bytes = os.path.getsize(filepath)\n                    size_str = self.format_file_size(size_bytes)\n                \n                self.tree.insert('', tk.END, values=(\n                    backup.get('name', ''),\n                    formatted_date,\n                    size_str,\n                    backup.get('type', 'Manual'),\n                    backup.get('status', 'OK')\n                ))\n                \n        except Exception as e:\n            logging.error(f\"Erro ao carregar backups: {e}\")\n            messagebox.showerror(\"Erro\", f\"Erro ao carregar backups:\\n{e}\")\n    \n    def format_file_size(self, size_bytes):\n        \"\"\"Formata tamanho do arquivo\"\"\"\n        if size_bytes == 0:\n            return \"0 B\"\n        \n        size_names = [\"B\", \"KB\", \"MB\", \"GB\"]\n        import math\n        i = int(math.floor(math.log(size_bytes, 1024)))\n        p = math.pow(1024, i)\n        s = round(size_bytes / p, 2)\n        \n        return f\"{s} {size_names[i]}\"\n    \n    def on_selection_change(self, event):\n        \"\"\"Callback para mudança de seleção\"\"\"\n        selection = self.tree.selection()\n        if not selection:\n            self.info_text.delete(1.0, tk.END)\n            return\n        \n        item = selection[0]\n        values = self.tree.item(item)['values']\n        \n        if not values or len(values) < 5:\n            self.info_text.delete(1.0, tk.END)\n            return\n        \n        # Busca informações detalhadas do backup\n        backup_name = values[0]\n        backups = self.backup_manager.list_backups()\n        \n        backup_info = None\n        for backup in backups:\n            if backup.get('name') == backup_name:\n                backup_info = backup\n                break\n        \n        if not backup_info:\n            self.info_text.delete(1.0, tk.END)\n            self.info_text.insert(1.0, \"Informações não disponíveis\")\n            return\n        \n        # Monta informações\n        info = f\"Nome: {backup_info.get('name', 'N/A')}\\n\"\n        info += f\"Data/Hora: {values[1]}\\n\"\n        info += f\"Tamanho: {values[2]}\\n\"\n        info += f\"Tipo: {backup_info.get('type', 'Manual')}\\n\"\n        info += f\"Descrição: {backup_info.get('description', 'Sem descrição')}\\n\"\n        info += f\"Arquivo: {backup_info.get('filepath', 'N/A')}\"\n        \n        # Atualiza text widget\n        self.info_text.delete(1.0, tk.END)\n        self.info_text.insert(1.0, info)\n    \n    def create_backup(self):\n        \"\"\"Cria um novo backup\"\"\"\n        try:\n            # Janela de confirmação com opções\n            dialog = BackupCreateDialog(self.window)\n            self.window.wait_window(dialog.window)\n            \n            if dialog.result:\n                description = dialog.result.get('description', '')\n                include_history = dialog.result.get('include_history', True)\n                \n                # Cria o backup\n                backup_info = self.backup_manager.create_backup(\n                    description=description,\n                    include_history=include_history\n                )\n                \n                if backup_info:\n                    messagebox.showinfo(\"Sucesso\", \"Backup criado com sucesso!\")\n                    self.load_backups()\n                else:\n                    messagebox.showerror(\"Erro\", \"Erro ao criar backup\")\n                    \n        except Exception as e:\n            logging.error(f\"Erro ao criar backup: {e}\")\n            messagebox.showerror(\"Erro\", f\"Erro ao criar backup:\\n{e}\")\n    \n    def restore_backup(self):\n        \"\"\"Restaura um backup selecionado\"\"\"\n        selection = self.tree.selection()\n        if not selection:\n            messagebox.showwarning(\"Aviso\", \"Selecione um backup para restaurar\")\n            return\n        \n        item = selection[0]\n        values = self.tree.item(item)['values']\n        \n        if not values:\n            return\n        \n        backup_name = values[0]\n        \n        # Confirma restauração\n        response = messagebox.askyesno(\n            \"Confirmar Restauração\",\n            f\"Deseja restaurar o backup '{backup_name}'?\\n\\n\"\n            \"ATENÇÃO: Esta ação irá substituir todos os dados atuais!\\n\"\n            \"Recomenda-se criar um backup antes de prosseguir.\"\n        )\n        \n        if not response:\n            return\n        \n        try:\n            # Cria backup de segurança antes da restauração\n            self.backup_manager.create_backup(\n                description=\"Backup automático antes da restauração\",\n                backup_type=\"pre_restore\"\n            )\n            \n            # Restaura o backup\n            success = self.backup_manager.restore_backup(backup_name)\n            \n            if success:\n                messagebox.showinfo(\n                    \"Sucesso\",\n                    \"Backup restaurado com sucesso!\\n\\n\"\n                    \"O sistema será atualizado automaticamente.\"\n                )\n                \n                # Chama callback se definido\n                if self.callback:\n                    self.callback()\n                    \n                self.window.destroy()\n            else:\n                messagebox.showerror(\"Erro\", \"Erro ao restaurar backup\")\n                \n        except Exception as e:\n            logging.error(f\"Erro ao restaurar backup: {e}\")\n            messagebox.showerror(\"Erro\", f\"Erro ao restaurar backup:\\n{e}\")\n    \n    def delete_backup(self):\n        \"\"\"Exclui um backup selecionado\"\"\"\n        selection = self.tree.selection()\n        if not selection:\n            messagebox.showwarning(\"Aviso\", \"Selecione um backup para excluir\")\n            return\n        \n        item = selection[0]\n        values = self.tree.item(item)['values']\n        \n        if not values:\n            return\n        \n        backup_name = values[0]\n        \n        # Confirma exclusão\n        response = messagebox.askyesno(\n            \"Confirmar Exclusão\",\n            f\"Deseja excluir o backup '{backup_name}'?\\n\\n\"\n            \"Esta ação não pode ser desfeita.\"\n        )\n        \n        if not response:\n            return\n        \n        try:\n            success = self.backup_manager.delete_backup(backup_name)\n            \n            if success:\n                messagebox.showinfo(\"Sucesso\", \"Backup excluído com sucesso!\")\n                self.load_backups()\n            else:\n                messagebox.showerror(\"Erro\", \"Erro ao excluir backup\")\n                \n        except Exception as e:\n            logging.error(f\"Erro ao excluir backup: {e}\")\n            messagebox.showerror(\"Erro\", f\"Erro ao excluir backup:\\n{e}\")\n    \n    def export_backup(self):\n        \"\"\"Exporta um backup para local específico\"\"\"\n        selection = self.tree.selection()\n        if not selection:\n            messagebox.showwarning(\"Aviso\", \"Selecione um backup para exportar\")\n            return\n        \n        item = selection[0]\n        values = self.tree.item(item)['values']\n        \n        if not values:\n            return\n        \n        backup_name = values[0]\n        \n        try:\n            from tkinter import filedialog\n            \n            # Seleciona destino\n            filename = filedialog.asksaveasfilename(\n                title=\"Exportar Backup\",\n                defaultextension=\".zip\",\n                filetypes=[(\"ZIP files\", \"*.zip\"), (\"Todos os arquivos\", \"*.*\")],\n                initialname=f\"{backup_name}.zip\"\n            )\n            \n            if not filename:\n                return\n            \n            success = self.backup_manager.export_backup(backup_name, filename)\n            \n            if success:\n                messagebox.showinfo(\"Sucesso\", f\"Backup exportado para:\\n{filename}\")\n            else:\n                messagebox.showerror(\"Erro\", \"Erro ao exportar backup\")\n                \n        except Exception as e:\n            logging.error(f\"Erro ao exportar backup: {e}\")\n            messagebox.showerror(\"Erro\", f\"Erro ao exportar backup:\\n{e}\")\n    \n    def toggle_auto_backup(self):\n        \"\"\"Alterna backup automático\"\"\"\n        enabled = self.auto_backup_var.get()\n        \n        try:\n            self.backup_manager.set_auto_backup(enabled)\n            \n            status = \"ativado\" if enabled else \"desativado\"\n            messagebox.showinfo(\"Backup Automático\", f\"Backup automático {status}\")\n            \n        except Exception as e:\n            logging.error(f\"Erro ao configurar backup automático: {e}\")\n            messagebox.showerror(\"Erro\", f\"Erro ao configurar backup automático:\\n{e}\")\n\n\nclass BackupCreateDialog:\n    \"\"\"Diálogo para criação de backup\"\"\"\n    \n    def __init__(self, parent):\n        \"\"\"Inicializa o diálogo\"\"\"\n        self.parent = parent\n        self.result = None\n        \n        # Cria a janela\n        self.window = tk.Toplevel(parent)\n        self.window.title(\"Criar Backup\")\n        self.window.geometry(\"400x300\")\n        self.window.resizable(False, False)\n        \n        # Modal\n        self.window.grab_set()\n        self.window.focus_set()\n        \n        # Centraliza\n        self.center_window()\n        \n        # Cria a interface\n        self.create_widgets()\n    \n    def center_window(self):\n        \"\"\"Centraliza a janela\"\"\"\n        self.window.update_idletasks()\n        \n        parent_x = self.parent.winfo_x()\n        parent_y = self.parent.winfo_y()\n        parent_width = self.parent.winfo_width()\n        parent_height = self.parent.winfo_height()\n        \n        width = 400\n        height = 300\n        \n        x = parent_x + (parent_width - width) // 2\n        y = parent_y + (parent_height - height) // 2\n        \n        self.window.geometry(f\"{width}x{height}+{x}+{y}\")\n    \n    def create_widgets(self):\n        \"\"\"Cria os widgets do diálogo\"\"\"\n        main_frame = ttk.Frame(self.window, padding=\"20\")\n        main_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Título\n        ttk.Label(\n            main_frame,\n            text=\"Criar Novo Backup\",\n            font=(\"Arial\", 14, \"bold\")\n        ).pack(pady=(0, 20))\n        \n        # Descrição\n        ttk.Label(main_frame, text=\"Descrição:\").pack(anchor=tk.W, pady=(0, 5))\n        self.description_var = tk.StringVar()\n        self.description_var.set(f\"Backup manual - {datetime.now().strftime('%d/%m/%Y %H:%M')}\")\n        \n        desc_entry = ttk.Entry(main_frame, textvariable=self.description_var, width=40)\n        desc_entry.pack(fill=tk.X, pady=(0, 20))\n        \n        # Opções\n        options_frame = ttk.LabelFrame(main_frame, text=\"Opções\", padding=\"10\")\n        options_frame.pack(fill=tk.X, pady=(0, 20))\n        \n        self.include_history_var = tk.BooleanVar(value=True)\n        ttk.Checkbutton(\n            options_frame,\n            text=\"Incluir histórico de alterações\",\n            variable=self.include_history_var\n        ).pack(anchor=tk.W)\n        \n        # Botões\n        button_frame = ttk.Frame(main_frame)\n        button_frame.pack(pady=20)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Criar\",\n            command=self.create_backup\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Cancelar\",\n            command=self.cancel\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Foco inicial\n        desc_entry.focus()\n        desc_entry.select_range(0, tk.END)\n    \n    def create_backup(self):\n        \"\"\"Confirma criação do backup\"\"\"\n        self.result = {\n            'description': self.description_var.get().strip(),\n            'include_history': self.include_history_var.get()\n        }\n        self.window.destroy()\n    \n    def cancel(self):\n        \"\"\"Cancela criação\"\"\"\n        self.result = None\n        self.window.destroy()\n","size_bytes":19154},"interface/history_window.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nJanela de Histórico do Professor - Sistema DIRENS\n\"\"\"\n\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nfrom datetime import datetime\nimport logging\n\nfrom dados.history_manager import HistoryManager\n\nclass HistoryWindow:\n    \"\"\"Janela para visualização do histórico de alterações\"\"\"\n    \n    def __init__(self, parent, siape, school):\n        \"\"\"Inicializa a janela de histórico\"\"\"\n        self.parent = parent\n        self.siape = siape\n        self.school = school\n        self.history_manager = HistoryManager()\n        \n        # Cria a janela\n        self.window = tk.Toplevel(parent)\n        self.window.title(f\"Histórico - Professor SIAPE: {siape}\")\n        self.window.geometry(\"900x600\")\n        self.window.resizable(True, True)\n        \n        # Modal\n        self.window.grab_set()\n        self.window.focus_set()\n        \n        # Centraliza\n        self.center_window()\n        \n        # Cria a interface\n        self.create_widgets()\n        \n        # Carrega dados\n        self.load_history()\n    \n    def center_window(self):\n        \"\"\"Centraliza a janela\"\"\"\n        self.window.update_idletasks()\n        \n        parent_x = self.parent.winfo_x()\n        parent_y = self.parent.winfo_y()\n        parent_width = self.parent.winfo_width()\n        parent_height = self.parent.winfo_height()\n        \n        width = 900\n        height = 600\n        \n        x = parent_x + (parent_width - width) // 2\n        y = parent_y + (parent_height - height) // 2\n        \n        self.window.geometry(f\"{width}x{height}+{x}+{y}\")\n    \n    def create_widgets(self):\n        \"\"\"Cria os widgets da interface\"\"\"\n        # Frame principal\n        main_frame = ttk.Frame(self.window, padding=\"10\")\n        main_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Título\n        title_frame = ttk.Frame(main_frame)\n        title_frame.pack(fill=tk.X, pady=(0, 10))\n        \n        ttk.Label(\n            title_frame,\n            text=f\"Histórico de Alterações - SIAPE: {self.siape}\",\n            font=(\"Arial\", 14, \"bold\")\n        ).pack(side=tk.LEFT)\n        \n        # Botão atualizar\n        ttk.Button(\n            title_frame,\n            text=\"Atualizar\",\n            command=self.load_history\n        ).pack(side=tk.RIGHT)\n        \n        # Frame da lista\n        list_frame = ttk.Frame(main_frame)\n        list_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))\n        \n        # Treeview com scrollbars\n        columns = (\"Data/Hora\", \"Ação\", \"Usuário\", \"Campo\", \"Valor Anterior\", \"Valor Novo\")\n        \n        self.tree = ttk.Treeview(list_frame, columns=columns, show=\"headings\", height=15)\n        \n        # Configurar colunas\n        column_widths = {\n            \"Data/Hora\": 140,\n            \"Ação\": 80,\n            \"Usuário\": 120,\n            \"Campo\": 150,\n            \"Valor Anterior\": 200,\n            \"Valor Novo\": 200\n        }\n        \n        for col in columns:\n            self.tree.heading(col, text=col)\n            self.tree.column(col, width=column_widths.get(col, 100), minwidth=50)\n        \n        # Scrollbars\n        v_scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.tree.yview)\n        h_scrollbar = ttk.Scrollbar(list_frame, orient=tk.HORIZONTAL, command=self.tree.xview)\n        \n        self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)\n        \n        # Grid layout\n        self.tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\n        v_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))\n        h_scrollbar.grid(row=1, column=0, sticky=(tk.W, tk.E))\n        \n        list_frame.grid_rowconfigure(0, weight=1)\n        list_frame.grid_columnconfigure(0, weight=1)\n        \n        # Frame de detalhes\n        details_frame = ttk.LabelFrame(main_frame, text=\"Detalhes da Alteração\", padding=\"10\")\n        details_frame.pack(fill=tk.X, pady=(0, 10))\n        \n        # Text widget para detalhes\n        self.details_text = tk.Text(details_frame, height=4, wrap=tk.WORD)\n        details_scroll = ttk.Scrollbar(details_frame, orient=tk.VERTICAL, command=self.details_text.yview)\n        self.details_text.configure(yscrollcommand=details_scroll.set)\n        \n        self.details_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        details_scroll.pack(side=tk.RIGHT, fill=tk.Y)\n        \n        # Evento de seleção\n        self.tree.bind('<<TreeviewSelect>>', self.on_selection_change)\n        \n        # Frame de estatísticas\n        stats_frame = ttk.LabelFrame(main_frame, text=\"Estatísticas\", padding=\"10\")\n        stats_frame.pack(fill=tk.X, pady=(0, 10))\n        \n        self.stats_var = tk.StringVar()\n        ttk.Label(stats_frame, textvariable=self.stats_var).pack()\n        \n        # Botões\n        button_frame = ttk.Frame(main_frame)\n        button_frame.pack(fill=tk.X)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Exportar Histórico\",\n            command=self.export_history\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Fechar\",\n            command=self.window.destroy\n        ).pack(side=tk.RIGHT, padx=5)\n    \n    def load_history(self):\n        \"\"\"Carrega o histórico do professor\"\"\"\n        try:\n            # Limpa a lista\n            for item in self.tree.get_children():\n                self.tree.delete(item)\n            \n            # Carrega histórico\n            history = self.history_manager.get_teacher_history(self.siape, self.school)\n            \n            if not history:\n                # Adiciona mensagem se não há histórico\n                self.tree.insert('', tk.END, values=(\n                    \"Nenhum histórico encontrado\", \"\", \"\", \"\", \"\", \"\"\n                ))\n                self.stats_var.set(\"Nenhuma alteração registrada\")\n                return\n            \n            # Ordena por data (mais recente primeiro)\n            history.sort(key=lambda x: x.get('timestamp', ''), reverse=True)\n            \n            # Adiciona itens à lista\n            for entry in history:\n                timestamp = entry.get('timestamp', '')\n                if timestamp:\n                    try:\n                        # Converte timestamp para formato legível\n                        dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))\n                        formatted_date = dt.strftime('%d/%m/%Y %H:%M')\n                    except:\n                        formatted_date = timestamp\n                else:\n                    formatted_date = ''\n                \n                self.tree.insert('', tk.END, values=(\n                    formatted_date,\n                    entry.get('action', ''),\n                    entry.get('user', ''),\n                    entry.get('field', ''),\n                    entry.get('old_value', ''),\n                    entry.get('new_value', '')\n                ))\n            \n            # Atualiza estatísticas\n            self.update_statistics(history)\n            \n        except Exception as e:\n            logging.error(f\"Erro ao carregar histórico: {e}\")\n            messagebox.showerror(\"Erro\", f\"Erro ao carregar histórico:\\n{e}\")\n    \n    def update_statistics(self, history):\n        \"\"\"Atualiza as estatísticas do histórico\"\"\"\n        if not history:\n            self.stats_var.set(\"Nenhuma alteração registrada\")\n            return\n        \n        # Conta ações\n        actions = {}\n        users = set()\n        \n        for entry in history:\n            action = entry.get('action', 'Desconhecida')\n            user = entry.get('user', 'Desconhecido')\n            \n            actions[action] = actions.get(action, 0) + 1\n            users.add(user)\n        \n        # Primeira e última alteração\n        first_change = history[-1].get('timestamp', '')\n        last_change = history[0].get('timestamp', '')\n        \n        try:\n            if first_change:\n                first_dt = datetime.fromisoformat(first_change.replace('Z', '+00:00'))\n                first_formatted = first_dt.strftime('%d/%m/%Y')\n            else:\n                first_formatted = 'N/A'\n                \n            if last_change:\n                last_dt = datetime.fromisoformat(last_change.replace('Z', '+00:00'))\n                last_formatted = last_dt.strftime('%d/%m/%Y')\n            else:\n                last_formatted = 'N/A'\n        except:\n            first_formatted = 'N/A'\n            last_formatted = 'N/A'\n        \n        # Monta string de estatísticas\n        stats_text = f\"Total de alterações: {len(history)} | \"\n        stats_text += f\"Usuários envolvidos: {len(users)} | \"\n        stats_text += f\"Primeira alteração: {first_formatted} | \"\n        stats_text += f\"Última alteração: {last_formatted}\"\n        \n        self.stats_var.set(stats_text)\n    \n    def on_selection_change(self, event):\n        \"\"\"Callback para mudança de seleção\"\"\"\n        selection = self.tree.selection()\n        if not selection:\n            self.details_text.delete(1.0, tk.END)\n            return\n        \n        item = selection[0]\n        values = self.tree.item(item)['values']\n        \n        if not values or len(values) < 6:\n            self.details_text.delete(1.0, tk.END)\n            return\n        \n        # Monta detalhes\n        details = f\"Data/Hora: {values[0]}\\n\"\n        details += f\"Ação: {values[1]}\\n\"\n        details += f\"Usuário: {values[2]}\\n\"\n        details += f\"Campo alterado: {values[3]}\\n\"\n        details += f\"Valor anterior: {values[4]}\\n\"\n        details += f\"Valor novo: {values[5]}\"\n        \n        # Atualiza text widget\n        self.details_text.delete(1.0, tk.END)\n        self.details_text.insert(1.0, details)\n    \n    def export_history(self):\n        \"\"\"Exporta o histórico para arquivo\"\"\"\n        try:\n            from tkinter import filedialog\n            \n            # Seleciona arquivo\n            filename = filedialog.asksaveasfilename(\n                title=\"Exportar Histórico\",\n                defaultextension=\".csv\",\n                filetypes=[(\"CSV files\", \"*.csv\"), (\"Todos os arquivos\", \"*.*\")],\n                initialname=f\"historico_siape_{self.siape}.csv\"\n            )\n            \n            if not filename:\n                return\n            \n            # Carrega dados\n            history = self.history_manager.get_teacher_history(self.siape, self.school)\n            \n            if not history:\n                messagebox.showwarning(\"Aviso\", \"Não há histórico para exportar\")\n                return\n            \n            # Exporta para CSV\n            import csv\n            \n            with open(filename, 'w', newline='', encoding='utf-8') as csvfile:\n                writer = csv.writer(csvfile)\n                \n                # Cabeçalho\n                writer.writerow([\n                    \"Data/Hora\", \"Ação\", \"Usuário\", \"Campo\", \n                    \"Valor Anterior\", \"Valor Novo\", \"Observações\"\n                ])\n                \n                # Dados\n                for entry in sorted(history, key=lambda x: x.get('timestamp', '')):\n                    timestamp = entry.get('timestamp', '')\n                    if timestamp:\n                        try:\n                            dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))\n                            formatted_date = dt.strftime('%d/%m/%Y %H:%M:%S')\n                        except:\n                            formatted_date = timestamp\n                    else:\n                        formatted_date = ''\n                    \n                    writer.writerow([\n                        formatted_date,\n                        entry.get('action', ''),\n                        entry.get('user', ''),\n                        entry.get('field', ''),\n                        entry.get('old_value', ''),\n                        entry.get('new_value', ''),\n                        entry.get('notes', '')\n                    ])\n            \n            messagebox.showinfo(\"Sucesso\", f\"Histórico exportado para:\\n{filename}\")\n            \n        except Exception as e:\n            logging.error(f\"Erro ao exportar histórico: {e}\")\n            messagebox.showerror(\"Erro\", f\"Erro ao exportar histórico:\\n{e}\")\n","size_bytes":12296},"interface/login.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nTela de Login do Sistema DIRENS\n\"\"\"\n\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport hashlib\nimport logging\n\nfrom core.auth import AuthManager\nfrom recursos.constants import ESCOLAS\n\nclass LoginWindow:\n    \"\"\"Janela de login do sistema\"\"\"\n    \n    def __init__(self, parent, sistema):\n        \"\"\"Inicializa a janela de login\"\"\"\n        self.parent = parent\n        self.sistema = sistema\n        self.auth_manager = AuthManager()\n        \n        # Cria a janela de login\n        self.window = tk.Toplevel(parent)\n        self.window.title(\"Sistema DIRENS - Login\")\n        self.window.geometry(\"400x500\")\n        self.window.resizable(False, False)\n        \n        # Centraliza a janela\n        self.center_window()\n        \n        # Configura o fechamento da janela\n        self.window.protocol(\"WM_DELETE_WINDOW\", self.on_close)\n        \n        # Cria a interface\n        self.create_widgets()\n        \n        # Foca na janela\n        self.window.focus_set()\n        self.window.grab_set()\n    \n    def center_window(self):\n        \"\"\"Centraliza a janela na tela\"\"\"\n        self.window.update_idletasks()\n        width = 400\n        height = 500\n        \n        screen_width = self.window.winfo_screenwidth()\n        screen_height = self.window.winfo_screenheight()\n        \n        x = (screen_width - width) // 2\n        y = (screen_height - height) // 2\n        \n        self.window.geometry(f\"{width}x{height}+{x}+{y}\")\n    \n    def create_widgets(self):\n        \"\"\"Cria os widgets da interface\"\"\"\n        # Frame principal\n        main_frame = ttk.Frame(self.window, padding=\"20\")\n        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\n        \n        # Configurar grid\n        self.window.grid_rowconfigure(0, weight=1)\n        self.window.grid_columnconfigure(0, weight=1)\n        main_frame.grid_columnconfigure(0, weight=1)\n        \n        # Título\n        title_label = ttk.Label(\n            main_frame,\n            text=\"Sistema DIRENS\",\n            font=(\"Arial\", 18, \"bold\")\n        )\n        title_label.grid(row=0, column=0, pady=(0, 10))\n        \n        # Subtítulo\n        subtitle_label = ttk.Label(\n            main_frame,\n            text=\"Controle de Professores\",\n            font=(\"Arial\", 12)\n        )\n        subtitle_label.grid(row=1, column=0, pady=(0, 30))\n        \n        # Frame do formulário\n        form_frame = ttk.LabelFrame(main_frame, text=\"Acesso ao Sistema\", padding=\"15\")\n        form_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 20))\n        form_frame.grid_columnconfigure(1, weight=1)\n        \n        # Escola\n        ttk.Label(form_frame, text=\"Escola:\").grid(row=0, column=0, sticky=tk.W, pady=(0, 10))\n        \n        self.escola_var = tk.StringVar()\n        escola_combo = ttk.Combobox(\n            form_frame,\n            textvariable=self.escola_var,\n            values=list(ESCOLAS.keys()),\n            state=\"readonly\",\n            width=30\n        )\n        escola_combo.grid(row=0, column=1, sticky=(tk.W, tk.E), pady=(0, 10))\n        \n        # Usuário\n        ttk.Label(form_frame, text=\"Usuário:\").grid(row=1, column=0, sticky=tk.W, pady=(0, 10))\n        \n        self.usuario_var = tk.StringVar()\n        usuario_entry = ttk.Entry(form_frame, textvariable=self.usuario_var, width=30)\n        usuario_entry.grid(row=1, column=1, sticky=(tk.W, tk.E), pady=(0, 10))\n        \n        # Senha\n        ttk.Label(form_frame, text=\"Senha:\").grid(row=2, column=0, sticky=tk.W, pady=(0, 10))\n        \n        self.senha_var = tk.StringVar()\n        senha_entry = ttk.Entry(form_frame, textvariable=self.senha_var, show=\"*\", width=30)\n        senha_entry.grid(row=2, column=1, sticky=(tk.W, tk.E), pady=(0, 10))\n        \n        # Bind Enter key\n        senha_entry.bind('<Return>', lambda e: self.login())\n        usuario_entry.bind('<Return>', lambda e: senha_entry.focus())\n        escola_combo.bind('<Return>', lambda e: usuario_entry.focus())\n        \n        # Botões\n        button_frame = ttk.Frame(main_frame)\n        button_frame.grid(row=3, column=0, pady=20)\n        \n        login_btn = ttk.Button(\n            button_frame,\n            text=\"Entrar\",\n            command=self.login,\n            width=15\n        )\n        login_btn.pack(side=tk.LEFT, padx=5)\n        \n        reset_btn = ttk.Button(\n            button_frame,\n            text=\"Redefinir Senha\",\n            command=self.reset_password,\n            width=15\n        )\n        reset_btn.pack(side=tk.LEFT, padx=5)\n        \n        # Status\n        self.status_var = tk.StringVar()\n        status_label = ttk.Label(main_frame, textvariable=self.status_var, foreground=\"red\")\n        status_label.grid(row=4, column=0, pady=10)\n        \n        # Informações do sistema\n        info_frame = ttk.LabelFrame(main_frame, text=\"Informações\", padding=\"10\")\n        info_frame.grid(row=5, column=0, sticky=(tk.W, tk.E), pady=(20, 0))\n        \n        info_text = tk.Text(info_frame, height=4, width=40, wrap=tk.WORD)\n        info_text.grid(row=0, column=0)\n        \n        info_content = \"\"\"Sistema de Controle de Professores DIRENS\nVersão 1.0 - Desktop Application\n\nPara primeiro acesso, use:\nUsuário: admin | Senha: direns2024\"\"\"\n        \n        info_text.insert(tk.END, info_content)\n        info_text.config(state=tk.DISABLED)\n        \n        # Foco inicial\n        escola_combo.focus()\n    \n    def login(self):\n        \"\"\"Realiza o login\"\"\"\n        escola = self.escola_var.get()\n        usuario = self.usuario_var.get().strip()\n        senha = self.senha_var.get()\n        \n        # Validações básicas\n        if not escola:\n            self.status_var.set(\"Selecione uma escola\")\n            return\n        \n        if not usuario:\n            self.status_var.set(\"Digite o usuário\")\n            return\n        \n        if not senha:\n            self.status_var.set(\"Digite a senha\")\n            return\n        \n        # Limpa status\n        self.status_var.set(\"\")\n        \n        try:\n            # Tenta autenticar\n            auth_result = self.auth_manager.authenticate(escola, usuario, senha)\n            \n            if auth_result['success']:\n                logging.info(f\"Login bem-sucedido: {usuario} - {escola}\")\n                \n                # Fecha a janela de login\n                self.window.destroy()\n                self.parent.destroy()\n                \n                # Chama callback de sucesso\n                user_data = {\n                    'username': usuario,\n                    'school': escola,\n                    'level': auth_result['level']\n                }\n                self.sistema.on_login_success(user_data)\n                \n            else:\n                self.status_var.set(auth_result['message'])\n                logging.warning(f\"Falha no login: {usuario} - {escola}\")\n                \n        except Exception as e:\n            self.status_var.set(\"Erro interno do sistema\")\n            logging.error(f\"Erro no login: {e}\")\n    \n    def reset_password(self):\n        \"\"\"Abre janela de redefinição de senha\"\"\"\n        ResetPasswordWindow(self.window, self.auth_manager)\n    \n    def on_close(self):\n        \"\"\"Fecha a aplicação\"\"\"\n        self.parent.quit()\n\n\nclass ResetPasswordWindow:\n    \"\"\"Janela para redefinição de senha\"\"\"\n    \n    def __init__(self, parent, auth_manager):\n        \"\"\"Inicializa a janela de redefinição\"\"\"\n        self.parent = parent\n        self.auth_manager = auth_manager\n        \n        # Cria a janela\n        self.window = tk.Toplevel(parent)\n        self.window.title(\"Redefinir Senha\")\n        self.window.geometry(\"350x300\")\n        self.window.resizable(False, False)\n        \n        # Centraliza\n        self.center_window()\n        \n        # Modal\n        self.window.grab_set()\n        self.window.focus_set()\n        \n        # Cria interface\n        self.create_widgets()\n    \n    def center_window(self):\n        \"\"\"Centraliza a janela\"\"\"\n        self.window.update_idletasks()\n        parent_x = self.parent.winfo_x()\n        parent_y = self.parent.winfo_y()\n        parent_width = self.parent.winfo_width()\n        parent_height = self.parent.winfo_height()\n        \n        width = 350\n        height = 300\n        \n        x = parent_x + (parent_width - width) // 2\n        y = parent_y + (parent_height - height) // 2\n        \n        self.window.geometry(f\"{width}x{height}+{x}+{y}\")\n    \n    def create_widgets(self):\n        \"\"\"Cria os widgets\"\"\"\n        main_frame = ttk.Frame(self.window, padding=\"20\")\n        main_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Título\n        ttk.Label(\n            main_frame,\n            text=\"Redefinir Senha\",\n            font=(\"Arial\", 14, \"bold\")\n        ).pack(pady=(0, 20))\n        \n        # Escola\n        ttk.Label(main_frame, text=\"Escola:\").pack(anchor=tk.W, pady=(0, 5))\n        self.escola_var = tk.StringVar()\n        ttk.Combobox(\n            main_frame,\n            textvariable=self.escola_var,\n            values=list(ESCOLAS.keys()),\n            state=\"readonly\"\n        ).pack(fill=tk.X, pady=(0, 10))\n        \n        # Usuário\n        ttk.Label(main_frame, text=\"Usuário:\").pack(anchor=tk.W, pady=(0, 5))\n        self.usuario_var = tk.StringVar()\n        ttk.Entry(main_frame, textvariable=self.usuario_var).pack(fill=tk.X, pady=(0, 10))\n        \n        # Senha atual (apenas para usuário comum)\n        ttk.Label(main_frame, text=\"Senha Atual:\").pack(anchor=tk.W, pady=(0, 5))\n        self.senha_atual_var = tk.StringVar()\n        ttk.Entry(main_frame, textvariable=self.senha_atual_var, show=\"*\").pack(fill=tk.X, pady=(0, 10))\n        \n        # Nova senha\n        ttk.Label(main_frame, text=\"Nova Senha:\").pack(anchor=tk.W, pady=(0, 5))\n        self.nova_senha_var = tk.StringVar()\n        ttk.Entry(main_frame, textvariable=self.nova_senha_var, show=\"*\").pack(fill=tk.X, pady=(0, 10))\n        \n        # Checkbox admin\n        self.is_admin_var = tk.BooleanVar()\n        ttk.Checkbutton(\n            main_frame,\n            text=\"Sou administrador (pode alterar qualquer senha)\",\n            variable=self.is_admin_var\n        ).pack(pady=10)\n        \n        # Botões\n        button_frame = ttk.Frame(main_frame)\n        button_frame.pack(pady=20)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Alterar\",\n            command=self.reset_password\n        ).pack(side=tk.LEFT, padx=5)\n        \n        ttk.Button(\n            button_frame,\n            text=\"Cancelar\",\n            command=self.window.destroy\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Status\n        self.status_var = tk.StringVar()\n        ttk.Label(main_frame, textvariable=self.status_var, foreground=\"red\").pack(pady=10)\n    \n    def reset_password(self):\n        \"\"\"Realiza a redefinição de senha\"\"\"\n        escola = self.escola_var.get()\n        usuario = self.usuario_var.get().strip()\n        senha_atual = self.senha_atual_var.get()\n        nova_senha = self.nova_senha_var.get()\n        is_admin = self.is_admin_var.get()\n        \n        # Validações\n        if not escola or not usuario or not nova_senha:\n            self.status_var.set(\"Preencha todos os campos obrigatórios\")\n            return\n        \n        if len(nova_senha) < 6:\n            self.status_var.set(\"Nova senha deve ter pelo menos 6 caracteres\")\n            return\n        \n        if not is_admin and not senha_atual:\n            self.status_var.set(\"Digite a senha atual\")\n            return\n        \n        try:\n            result = self.auth_manager.reset_password(\n                escola, usuario, senha_atual, nova_senha, is_admin\n            )\n            \n            if result['success']:\n                messagebox.showinfo(\"Sucesso\", result['message'])\n                self.window.destroy()\n            else:\n                self.status_var.set(result['message'])\n                \n        except Exception as e:\n            self.status_var.set(\"Erro interno do sistema\")\n            logging.error(f\"Erro ao redefinir senha: {e}\")\n","size_bytes":12068},"interface/main_window.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nJanela Principal do Sistema DIRENS\n\"\"\"\n\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport logging\nfrom datetime import datetime\n\nfrom interface.teacher_form import TeacherFormWindow\nfrom interface.history_window import HistoryWindow\nfrom interface.backup_window import BackupWindow\nfrom interface.statistics_window import StatisticsWindow\nfrom core.teacher_manager import TeacherManager\nfrom core.export_manager import ExportManager\nfrom recursos.constants import CARGAS_HORARIAS, CARREIRAS, POS_GRADUACAO\n\nclass MainWindow:\n    \"\"\"Janela principal do sistema\"\"\"\n    \n    def __init__(self, root, sistema):\n        \"\"\"Inicializa a janela principal\"\"\"\n        self.root = root\n        self.sistema = sistema\n        self.teacher_manager = TeacherManager()\n        self.export_manager = ExportManager()\n        \n        # Configurações da janela\n        self.root.title(f\"Sistema DIRENS - {sistema.current_school}\")\n        self.root.geometry(\"1200x800\")\n        self.root.state('zoomed')  # Maximiza no Windows\n        \n        # Variáveis de filtro\n        self.filter_pos = tk.StringVar()\n        self.filter_carga = tk.StringVar()\n        self.filter_carreira = tk.StringVar()\n        self.search_var = tk.StringVar()\n        \n        # Bind para busca em tempo real\n        self.search_var.trace('w', self.on_search_change)\n        \n        # Cria a interface\n        self.create_widgets()\n        \n        # Carrega dados iniciais\n        self.refresh_data()\n        \n        # Configura fechamento\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.on_close)\n    \n    def create_widgets(self):\n        \"\"\"Cria os widgets da interface\"\"\"\n        # Menu principal\n        self.create_menu()\n        \n        # Toolbar\n        self.create_toolbar()\n        \n        # Frame principal\n        main_frame = ttk.Frame(self.root)\n        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)\n        \n        # Frame de filtros\n        self.create_filters_frame(main_frame)\n        \n        # Frame da lista\n        self.create_list_frame(main_frame)\n        \n        # Status bar\n        self.create_status_bar()\n    \n    def create_menu(self):\n        \"\"\"Cria o menu principal\"\"\"\n        menubar = tk.Menu(self.root)\n        self.root.config(menu=menubar)\n        \n        # Menu Arquivo\n        arquivo_menu = tk.Menu(menubar, tearoff=0)\n        menubar.add_cascade(label=\"Arquivo\", menu=arquivo_menu)\n        arquivo_menu.add_command(label=\"Novo Professor\", command=self.new_teacher, accelerator=\"Ctrl+N\")\n        arquivo_menu.add_separator()\n        arquivo_menu.add_command(label=\"Exportar CSV\", command=self.export_csv)\n        arquivo_menu.add_command(label=\"Exportar PDF\", command=self.export_pdf)\n        arquivo_menu.add_separator()\n        arquivo_menu.add_command(label=\"Sair\", command=self.on_close, accelerator=\"Ctrl+Q\")\n        \n        # Menu Editar\n        editar_menu = tk.Menu(menubar, tearoff=0)\n        menubar.add_cascade(label=\"Editar\", menu=editar_menu)\n        editar_menu.add_command(label=\"Editar Professor\", command=self.edit_teacher, accelerator=\"F2\")\n        editar_menu.add_command(label=\"Excluir Professor\", command=self.delete_teacher, accelerator=\"Del\")\n        editar_menu.add_separator()\n        editar_menu.add_command(label=\"Histórico\", command=self.show_history, accelerator=\"F3\")\n        \n        # Menu Ferramentas\n        tools_menu = tk.Menu(menubar, tearoff=0)\n        menubar.add_cascade(label=\"Ferramentas\", menu=tools_menu)\n        tools_menu.add_command(label=\"Estatísticas\", command=self.show_statistics)\n        tools_menu.add_command(label=\"Backups\", command=self.show_backups)\n        tools_menu.add_command(label=\"Atualizar\", command=self.refresh_data, accelerator=\"F5\")\n        \n        # Menu Ajuda\n        help_menu = tk.Menu(menubar, tearoff=0)\n        menubar.add_cascade(label=\"Ajuda\", menu=help_menu)\n        help_menu.add_command(label=\"Sobre\", command=self.show_about)\n        \n        # Atalhos do teclado\n        self.root.bind('<Control-n>', lambda e: self.new_teacher())\n        self.root.bind('<Control-q>', lambda e: self.on_close())\n        self.root.bind('<F2>', lambda e: self.edit_teacher())\n        self.root.bind('<Delete>', lambda e: self.delete_teacher())\n        self.root.bind('<F3>', lambda e: self.show_history())\n        self.root.bind('<F5>', lambda e: self.refresh_data())\n    \n    def create_toolbar(self):\n        \"\"\"Cria a barra de ferramentas\"\"\"\n        toolbar = ttk.Frame(self.root)\n        toolbar.pack(fill=tk.X, padx=10, pady=5)\n        \n        # Botões principais\n        ttk.Button(\n            toolbar,\n            text=\"Novo Professor\",\n            command=self.new_teacher\n        ).pack(side=tk.LEFT, padx=2)\n        \n        ttk.Separator(toolbar, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=5)\n        \n        ttk.Button(\n            toolbar,\n            text=\"Editar\",\n            command=self.edit_teacher\n        ).pack(side=tk.LEFT, padx=2)\n        \n        ttk.Button(\n            toolbar,\n            text=\"Excluir\",\n            command=self.delete_teacher\n        ).pack(side=tk.LEFT, padx=2)\n        \n        ttk.Separator(toolbar, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=5)\n        \n        ttk.Button(\n            toolbar,\n            text=\"Histórico\",\n            command=self.show_history\n        ).pack(side=tk.LEFT, padx=2)\n        \n        ttk.Button(\n            toolbar,\n            text=\"Estatísticas\",\n            command=self.show_statistics\n        ).pack(side=tk.LEFT, padx=2)\n        \n        ttk.Separator(toolbar, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=5)\n        \n        ttk.Button(\n            toolbar,\n            text=\"Exportar CSV\",\n            command=self.export_csv\n        ).pack(side=tk.LEFT, padx=2)\n        \n        ttk.Button(\n            toolbar,\n            text=\"Exportar PDF\",\n            command=self.export_pdf\n        ).pack(side=tk.LEFT, padx=2)\n        \n        # Informações do usuário (direita)\n        user_frame = ttk.Frame(toolbar)\n        user_frame.pack(side=tk.RIGHT)\n        \n        ttk.Label(\n            user_frame,\n            text=f\"Usuário: {self.sistema.current_user} | Escola: {self.sistema.current_school}\"\n        ).pack(side=tk.RIGHT, padx=10)\n        \n        ttk.Button(\n            user_frame,\n            text=\"Logout\",\n            command=self.logout\n        ).pack(side=tk.RIGHT)\n    \n    def create_filters_frame(self, parent):\n        \"\"\"Cria o frame de filtros\"\"\"\n        filters_frame = ttk.LabelFrame(parent, text=\"Filtros e Busca\", padding=\"10\")\n        filters_frame.pack(fill=tk.X, pady=(0, 10))\n        \n        # Primeira linha - filtros\n        filter_row1 = ttk.Frame(filters_frame)\n        filter_row1.pack(fill=tk.X, pady=(0, 10))\n        \n        # Pós-graduação\n        ttk.Label(filter_row1, text=\"Pós-graduação:\").pack(side=tk.LEFT, padx=(0, 5))\n        ttk.Combobox(\n            filter_row1,\n            textvariable=self.filter_pos,\n            values=[\"Todos\"] + POS_GRADUACAO,\n            state=\"readonly\",\n            width=15\n        ).pack(side=tk.LEFT, padx=(0, 20))\n        \n        # Carga horária\n        ttk.Label(filter_row1, text=\"Carga Horária:\").pack(side=tk.LEFT, padx=(0, 5))\n        ttk.Combobox(\n            filter_row1,\n            textvariable=self.filter_carga,\n            values=[\"Todos\"] + CARGAS_HORARIAS,\n            state=\"readonly\",\n            width=15\n        ).pack(side=tk.LEFT, padx=(0, 20))\n        \n        # Carreira\n        ttk.Label(filter_row1, text=\"Carreira:\").pack(side=tk.LEFT, padx=(0, 5))\n        ttk.Combobox(\n            filter_row1,\n            textvariable=self.filter_carreira,\n            values=[\"Todos\"] + CARREIRAS,\n            state=\"readonly\",\n            width=15\n        ).pack(side=tk.LEFT, padx=(0, 20))\n        \n        # Botão limpar filtros\n        ttk.Button(\n            filter_row1,\n            text=\"Limpar Filtros\",\n            command=self.clear_filters\n        ).pack(side=tk.LEFT, padx=20)\n        \n        # Segunda linha - busca\n        search_row = ttk.Frame(filters_frame)\n        search_row.pack(fill=tk.X)\n        \n        ttk.Label(search_row, text=\"Buscar (Nome/SIAPE):\").pack(side=tk.LEFT, padx=(0, 10))\n        search_entry = ttk.Entry(search_row, textvariable=self.search_var, width=30)\n        search_entry.pack(side=tk.LEFT)\n        \n        # Contador de registros\n        self.count_var = tk.StringVar()\n        ttk.Label(search_row, textvariable=self.count_var).pack(side=tk.RIGHT, padx=10)\n        \n        # Configurar eventos de filtro\n        self.filter_pos.trace('w', self.apply_filters)\n        self.filter_carga.trace('w', self.apply_filters)\n        self.filter_carreira.trace('w', self.apply_filters)\n        \n        # Definir valores padrão\n        self.filter_pos.set(\"Todos\")\n        self.filter_carga.set(\"Todos\")\n        self.filter_carreira.set(\"Todos\")\n    \n    def create_list_frame(self, parent):\n        \"\"\"Cria o frame da lista de professores\"\"\"\n        list_frame = ttk.Frame(parent)\n        list_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Treeview com scrollbars\n        tree_frame = ttk.Frame(list_frame)\n        tree_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Colunas da lista\n        columns = (\n            \"SIAPE\", \"Nome\", \"Data Nascimento\", \"Carga Horária\",\n            \"Carreira\", \"Pós-graduação\", \"Data Ingresso\", \"Status\"\n        )\n        \n        self.tree = ttk.Treeview(tree_frame, columns=columns, show=\"headings\", height=20)\n        \n        # Configurar colunas\n        column_widths = {\n            \"SIAPE\": 100,\n            \"Nome\": 250,\n            \"Data Nascimento\": 120,\n            \"Carga Horária\": 100,\n            \"Carreira\": 100,\n            \"Pós-graduação\": 130,\n            \"Data Ingresso\": 120,\n            \"Status\": 100\n        }\n        \n        for col in columns:\n            self.tree.heading(col, text=col, command=lambda c=col: self.sort_column(c))\n            self.tree.column(col, width=column_widths.get(col, 100), minwidth=50)\n        \n        # Scrollbars\n        v_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.tree.yview)\n        h_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.tree.xview)\n        \n        self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)\n        \n        # Grid layout\n        self.tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\n        v_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))\n        h_scrollbar.grid(row=1, column=0, sticky=(tk.W, tk.E))\n        \n        tree_frame.grid_rowconfigure(0, weight=1)\n        tree_frame.grid_columnconfigure(0, weight=1)\n        \n        # Eventos\n        self.tree.bind('<Double-1>', lambda e: self.edit_teacher())\n        self.tree.bind('<Return>', lambda e: self.edit_teacher())\n    \n    def create_status_bar(self):\n        \"\"\"Cria a barra de status\"\"\"\n        status_frame = ttk.Frame(self.root)\n        status_frame.pack(fill=tk.X, side=tk.BOTTOM)\n        \n        self.status_var = tk.StringVar()\n        self.status_var.set(\"Pronto\")\n        \n        ttk.Label(status_frame, textvariable=self.status_var).pack(side=tk.LEFT, padx=10, pady=5)\n        \n        # Data/hora atual\n        self.datetime_var = tk.StringVar()\n        ttk.Label(status_frame, textvariable=self.datetime_var).pack(side=tk.RIGHT, padx=10, pady=5)\n        \n        # Atualizar data/hora\n        self.update_datetime()\n    \n    def update_datetime(self):\n        \"\"\"Atualiza data e hora na barra de status\"\"\"\n        now = datetime.now()\n        self.datetime_var.set(now.strftime(\"%d/%m/%Y %H:%M:%S\"))\n        self.root.after(1000, self.update_datetime)\n    \n    def refresh_data(self):\n        \"\"\"Atualiza a lista de professores\"\"\"\n        try:\n            self.status_var.set(\"Carregando dados...\")\n            \n            # Limpa a lista\n            for item in self.tree.get_children():\n                self.tree.delete(item)\n            \n            # Carrega professores da escola atual\n            professores = self.teacher_manager.get_teachers_by_school(self.sistema.current_school)\n            \n            # Aplica filtros\n            professores_filtrados = self.apply_current_filters(professores)\n            \n            # Adiciona à lista\n            for professor in professores_filtrados:\n                self.tree.insert('', tk.END, values=(\n                    professor.get('siape', ''),\n                    professor.get('nome', ''),\n                    professor.get('data_nascimento', ''),\n                    professor.get('carga_horaria', ''),\n                    professor.get('carreira', ''),\n                    professor.get('pos_graduacao', ''),\n                    professor.get('data_ingresso', ''),\n                    professor.get('status', 'Ativo')\n                ))\n            \n            # Atualiza contador\n            total = len(professores)\n            filtrados = len(professores_filtrados)\n            self.count_var.set(f\"{filtrados} de {total} professores\")\n            \n            self.status_var.set(\"Dados carregados\")\n            \n        except Exception as e:\n            logging.error(f\"Erro ao carregar dados: {e}\")\n            self.status_var.set(\"Erro ao carregar dados\")\n            messagebox.showerror(\"Erro\", f\"Erro ao carregar dados:\\n{e}\")\n    \n    def apply_current_filters(self, professores):\n        \"\"\"Aplica os filtros atuais aos professores\"\"\"\n        filtrados = professores.copy()\n        \n        # Filtro por pós-graduação\n        if self.filter_pos.get() and self.filter_pos.get() != \"Todos\":\n            filtrados = [p for p in filtrados if p.get('pos_graduacao') == self.filter_pos.get()]\n        \n        # Filtro por carga horária\n        if self.filter_carga.get() and self.filter_carga.get() != \"Todos\":\n            filtrados = [p for p in filtrados if p.get('carga_horaria') == self.filter_carga.get()]\n        \n        # Filtro por carreira\n        if self.filter_carreira.get() and self.filter_carreira.get() != \"Todos\":\n            filtrados = [p for p in filtrados if p.get('carreira') == self.filter_carreira.get()]\n        \n        # Filtro por busca\n        search_term = self.search_var.get().strip().lower()\n        if search_term:\n            filtrados = [\n                p for p in filtrados\n                if search_term in p.get('nome', '').lower() or \n                   search_term in p.get('siape', '')\n            ]\n        \n        return filtrados\n    \n    def apply_filters(self, *args):\n        \"\"\"Aplica filtros quando alterados\"\"\"\n        self.refresh_data()\n    \n    def on_search_change(self, *args):\n        \"\"\"Callback para mudança na busca\"\"\"\n        # Aplica busca com delay para evitar muitas chamadas\n        if hasattr(self, '_search_timer'):\n            self.root.after_cancel(self._search_timer)\n        \n        self._search_timer = self.root.after(300, self.refresh_data)\n    \n    def clear_filters(self):\n        \"\"\"Limpa todos os filtros\"\"\"\n        self.filter_pos.set(\"Todos\")\n        self.filter_carga.set(\"Todos\")\n        self.filter_carreira.set(\"Todos\")\n        self.search_var.set(\"\")\n    \n    def sort_column(self, column):\n        \"\"\"Ordena por coluna\"\"\"\n        # Implementação básica de ordenação\n        items = [(self.tree.item(item)['values'], item) for item in self.tree.get_children()]\n        \n        col_index = list(self.tree['columns']).index(column)\n        \n        # Ordena numericamente se for SIAPE, caso contrário alfabeticamente\n        if column == \"SIAPE\":\n            items.sort(key=lambda x: int(x[0][col_index]) if x[0][col_index].isdigit() else 0)\n        else:\n            items.sort(key=lambda x: str(x[0][col_index]).lower())\n        \n        # Reordena os itens\n        for index, (values, item) in enumerate(items):\n            self.tree.move(item, '', index)\n    \n    def get_selected_teacher(self):\n        \"\"\"Retorna o professor selecionado\"\"\"\n        selection = self.tree.selection()\n        if not selection:\n            return None\n        \n        item = selection[0]\n        values = self.tree.item(item)['values']\n        \n        if not values:\n            return None\n        \n        return {\n            'siape': values[0],\n            'nome': values[1],\n            'data_nascimento': values[2],\n            'carga_horaria': values[3],\n            'carreira': values[4],\n            'pos_graduacao': values[5],\n            'data_ingresso': values[6],\n            'status': values[7] if len(values) > 7 else 'Ativo'\n        }\n    \n    def new_teacher(self):\n        \"\"\"Abre formulário para novo professor\"\"\"\n        TeacherFormWindow(self.root, self.teacher_manager, self.sistema.current_school, callback=self.refresh_data)\n    \n    def edit_teacher(self):\n        \"\"\"Edita o professor selecionado\"\"\"\n        selected = self.get_selected_teacher()\n        if not selected:\n            messagebox.showwarning(\"Aviso\", \"Selecione um professor para editar\")\n            return\n        \n        # Carrega dados completos do professor\n        professor_completo = self.teacher_manager.get_teacher_by_siape(\n            selected['siape'], self.sistema.current_school\n        )\n        \n        if professor_completo:\n            TeacherFormWindow(\n                self.root, \n                self.teacher_manager, \n                self.sistema.current_school,\n                teacher_data=professor_completo,\n                callback=self.refresh_data\n            )\n    \n    def delete_teacher(self):\n        \"\"\"Exclui o professor selecionado\"\"\"\n        selected = self.get_selected_teacher()\n        if not selected:\n            messagebox.showwarning(\"Aviso\", \"Selecione um professor para excluir\")\n            return\n        \n        # Confirma exclusão\n        response = messagebox.askyesno(\n            \"Confirmar Exclusão\",\n            f\"Deseja realmente excluir o professor:\\n{selected['nome']} (SIAPE: {selected['siape']})?\\n\\nEsta ação não pode ser desfeita.\"\n        )\n        \n        if response:\n            try:\n                success = self.teacher_manager.delete_teacher(\n                    selected['siape'], \n                    self.sistema.current_school,\n                    self.sistema.current_user\n                )\n                \n                if success:\n                    messagebox.showinfo(\"Sucesso\", \"Professor excluído com sucesso\")\n                    self.refresh_data()\n                else:\n                    messagebox.showerror(\"Erro\", \"Erro ao excluir professor\")\n                    \n            except Exception as e:\n                logging.error(f\"Erro ao excluir professor: {e}\")\n                messagebox.showerror(\"Erro\", f\"Erro ao excluir professor:\\n{e}\")\n    \n    def show_history(self):\n        \"\"\"Mostra histórico do professor selecionado\"\"\"\n        selected = self.get_selected_teacher()\n        if not selected:\n            messagebox.showwarning(\"Aviso\", \"Selecione um professor para ver o histórico\")\n            return\n        \n        HistoryWindow(self.root, selected['siape'], self.sistema.current_school)\n    \n    def show_statistics(self):\n        \"\"\"Mostra janela de estatísticas\"\"\"\n        StatisticsWindow(self.root, self.teacher_manager, self.sistema.current_school)\n    \n    def show_backups(self):\n        \"\"\"Mostra janela de backups\"\"\"\n        BackupWindow(self.root, callback=self.refresh_data)\n    \n    def export_csv(self):\n        \"\"\"Exporta para CSV\"\"\"\n        try:\n            self.status_var.set(\"Exportando CSV...\")\n            \n            professores = self.teacher_manager.get_teachers_by_school(self.sistema.current_school)\n            filepath = self.export_manager.export_csv(professores, self.sistema.current_school)\n            \n            self.status_var.set(\"CSV exportado com sucesso\")\n            messagebox.showinfo(\"Sucesso\", f\"Dados exportados para:\\n{filepath}\")\n            \n        except Exception as e:\n            logging.error(f\"Erro ao exportar CSV: {e}\")\n            self.status_var.set(\"Erro na exportação\")\n            messagebox.showerror(\"Erro\", f\"Erro ao exportar CSV:\\n{e}\")\n    \n    def export_pdf(self):\n        \"\"\"Exporta para PDF\"\"\"\n        try:\n            self.status_var.set(\"Exportando PDF...\")\n            \n            professores = self.teacher_manager.get_teachers_by_school(self.sistema.current_school)\n            filepath = self.export_manager.export_pdf(professores, self.sistema.current_school)\n            \n            self.status_var.set(\"PDF exportado com sucesso\")\n            messagebox.showinfo(\"Sucesso\", f\"Relatório exportado para:\\n{filepath}\")\n            \n        except Exception as e:\n            logging.error(f\"Erro ao exportar PDF: {e}\")\n            self.status_var.set(\"Erro na exportação\")\n            messagebox.showerror(\"Erro\", f\"Erro ao exportar PDF:\\n{e}\")\n    \n    def show_about(self):\n        \"\"\"Mostra informações sobre o sistema\"\"\"\n        about_text = \"\"\"Sistema DIRENS - Controle de Professores\nVersão 1.0\n\nAplicação Desktop desenvolvida em Python + Tkinter\npara gerenciamento de professores das escolas\nsubordinadas à DIRENS.\n\nFuncionalidades:\n• Cadastro completo de professores\n• Controle de acesso por escola\n• Histórico de alterações\n• Exportações (CSV/PDF)\n• Backups automáticos\n• Estatísticas e relatórios\n\nDesenvolvido em 2024\"\"\"\n        \n        messagebox.showinfo(\"Sobre o Sistema\", about_text)\n    \n    def logout(self):\n        \"\"\"Realiza logout do sistema\"\"\"\n        response = messagebox.askyesno(\"Logout\", \"Deseja realmente sair do sistema?\")\n        if response:\n            self.root.destroy()\n            self.sistema.logout()\n            \n            # Reinicia o sistema\n            from interface.login import LoginWindow\n            new_root = tk.Tk()\n            new_root.withdraw()\n            LoginWindow(new_root, self.sistema)\n            new_root.mainloop()\n    \n    def on_close(self):\n        \"\"\"Fecha a aplicação\"\"\"\n        response = messagebox.askyesno(\"Sair\", \"Deseja realmente fechar o sistema?\")\n        if response:\n            logging.info(\"Sistema encerrado pelo usuário\")\n            self.root.quit()\n","size_bytes":22272},"interface/statistics_window.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nJanela de Estatísticas - Sistema DIRENS\n\"\"\"\n\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport logging\nfrom collections import Counter\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\nimport numpy as np\n\nfrom recursos.constants import CARGAS_HORARIAS, CARREIRAS, POS_GRADUACAO\n\nclass StatisticsWindow:\n    \"\"\"Janela para visualização de estatísticas\"\"\"\n    \n    def __init__(self, parent, teacher_manager, school):\n        \"\"\"Inicializa a janela de estatísticas\"\"\"\n        self.parent = parent\n        self.teacher_manager = teacher_manager\n        self.school = school\n        \n        # Cria a janela\n        self.window = tk.Toplevel(parent)\n        self.window.title(f\"Estatísticas - {school}\")\n        self.window.geometry(\"1000x700\")\n        self.window.resizable(True, True)\n        \n        # Modal\n        self.window.grab_set()\n        self.window.focus_set()\n        \n        # Centraliza\n        self.center_window()\n        \n        # Cria a interface\n        self.create_widgets()\n        \n        # Carrega dados\n        self.load_statistics()\n    \n    def center_window(self):\n        \"\"\"Centraliza a janela\"\"\"\n        self.window.update_idletasks()\n        \n        parent_x = self.parent.winfo_x()\n        parent_y = self.parent.winfo_y()\n        parent_width = self.parent.winfo_width()\n        parent_height = self.parent.winfo_height()\n        \n        width = 1000\n        height = 700\n        \n        x = parent_x + (parent_width - width) // 2\n        y = parent_y + (parent_height - height) // 2\n        \n        self.window.geometry(f\"{width}x{height}+{x}+{y}\")\n    \n    def create_widgets(self):\n        \"\"\"Cria os widgets da interface\"\"\"\n        # Frame principal\n        main_frame = ttk.Frame(self.window, padding=\"10\")\n        main_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Título\n        header_frame = ttk.Frame(main_frame)\n        header_frame.pack(fill=tk.X, pady=(0, 10))\n        \n        ttk.Label(\n            header_frame,\n            text=f\"Estatísticas - {self.school}\",\n            font=(\"Arial\", 16, \"bold\")\n        ).pack(side=tk.LEFT)\n        \n        ttk.Button(\n            header_frame,\n            text=\"Atualizar\",\n            command=self.load_statistics\n        ).pack(side=tk.RIGHT)\n        \n        ttk.Button(\n            header_frame,\n            text=\"Exportar Relatório\",\n            command=self.export_report\n        ).pack(side=tk.RIGHT, padx=(0, 10))\n        \n        # Notebook para abas\n        self.notebook = ttk.Notebook(main_frame)\n        self.notebook.pack(fill=tk.BOTH, expand=True, pady=(0, 10))\n        \n        # Aba de resumo\n        self.create_summary_tab()\n        \n        # Aba de gráficos\n        self.create_charts_tab()\n        \n        # Aba de detalhes\n        self.create_details_tab()\n        \n        # Botão fechar\n        ttk.Button(\n            main_frame,\n            text=\"Fechar\",\n            command=self.window.destroy\n        ).pack(pady=10)\n    \n    def create_summary_tab(self):\n        \"\"\"Cria aba de resumo\"\"\"\n        summary_frame = ttk.Frame(self.notebook, padding=\"10\")\n        self.notebook.add(summary_frame, text=\"Resumo Geral\")\n        \n        # Frame para cards de estatísticas\n        cards_frame = ttk.Frame(summary_frame)\n        cards_frame.pack(fill=tk.X, pady=(0, 20))\n        \n        # Cards de estatísticas principais\n        self.create_stat_card(cards_frame, \"Total de Professores\", \"total_professores\", 0, 0)\n        self.create_stat_card(cards_frame, \"Professores Ativos\", \"professores_ativos\", 0, 1)\n        self.create_stat_card(cards_frame, \"40H Dedicação Exclusiva\", \"professores_40h_de\", 0, 2)\n        self.create_stat_card(cards_frame, \"Com Doutorado\", \"professores_doutorado\", 1, 0)\n        self.create_stat_card(cards_frame, \"Com Mestrado\", \"professores_mestrado\", 1, 1)\n        self.create_stat_card(cards_frame, \"Carreira EBTT\", \"professores_ebtt\", 1, 2)\n        \n        # Tabela de distribuição\n        table_frame = ttk.LabelFrame(summary_frame, text=\"Distribuição por Categoria\", padding=\"10\")\n        table_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Treeview para tabela\n        columns = (\"Categoria\", \"Quantidade\", \"Percentual\")\n        self.summary_tree = ttk.Treeview(table_frame, columns=columns, show=\"headings\", height=10)\n        \n        for col in columns:\n            self.summary_tree.heading(col, text=col)\n            self.summary_tree.column(col, width=150, anchor=tk.CENTER)\n        \n        # Scrollbar\n        scrollbar = ttk.Scrollbar(table_frame, orient=tk.VERTICAL, command=self.summary_tree.yview)\n        self.summary_tree.configure(yscrollcommand=scrollbar.set)\n        \n        self.summary_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n    \n    def create_stat_card(self, parent, title, var_name, row, col):\n        \"\"\"Cria um card de estatística\"\"\"\n        card_frame = ttk.LabelFrame(parent, text=title, padding=\"10\")\n        card_frame.grid(row=row, column=col, padx=5, pady=5, sticky=(tk.W, tk.E))\n        \n        # Variável para o valor\n        var = tk.StringVar()\n        setattr(self, f\"{var_name}_var\", var)\n        \n        # Label com valor grande\n        value_label = ttk.Label(\n            card_frame,\n            textvariable=var,\n            font=(\"Arial\", 20, \"bold\"),\n            anchor=tk.CENTER\n        )\n        value_label.pack()\n        \n        # Configura grid\n        parent.grid_columnconfigure(col, weight=1)\n    \n    def create_charts_tab(self):\n        \"\"\"Cria aba de gráficos\"\"\"\n        charts_frame = ttk.Frame(self.notebook, padding=\"10\")\n        self.notebook.add(charts_frame, text=\"Gráficos\")\n        \n        # Frame para os gráficos\n        self.charts_container = ttk.Frame(charts_frame)\n        self.charts_container.pack(fill=tk.BOTH, expand=True)\n    \n    def create_details_tab(self):\n        \"\"\"Cria aba de detalhes\"\"\"\n        details_frame = ttk.Frame(self.notebook, padding=\"10\")\n        self.notebook.add(details_frame, text=\"Detalhes\")\n        \n        # Frame para filtros\n        filter_frame = ttk.LabelFrame(details_frame, text=\"Filtros\", padding=\"10\")\n        filter_frame.pack(fill=tk.X, pady=(0, 10))\n        \n        # Filtros\n        ttk.Label(filter_frame, text=\"Pós-graduação:\").pack(side=tk.LEFT, padx=(0, 5))\n        self.detail_pos_var = tk.StringVar()\n        ttk.Combobox(\n            filter_frame,\n            textvariable=self.detail_pos_var,\n            values=[\"Todos\"] + POS_GRADUACAO,\n            state=\"readonly\",\n            width=15\n        ).pack(side=tk.LEFT, padx=(0, 20))\n        \n        ttk.Label(filter_frame, text=\"Carreira:\").pack(side=tk.LEFT, padx=(0, 5))\n        self.detail_carreira_var = tk.StringVar()\n        ttk.Combobox(\n            filter_frame,\n            textvariable=self.detail_carreira_var,\n            values=[\"Todos\"] + CARREIRAS,\n            state=\"readonly\",\n            width=15\n        ).pack(side=tk.LEFT, padx=(0, 20))\n        \n        ttk.Button(\n            filter_frame,\n            text=\"Aplicar Filtros\",\n            command=self.apply_detail_filters\n        ).pack(side=tk.LEFT, padx=20)\n        \n        # Lista detalhada\n        list_frame = ttk.Frame(details_frame)\n        list_frame.pack(fill=tk.BOTH, expand=True)\n        \n        columns = (\"SIAPE\", \"Nome\", \"Carreira\", \"Carga Horária\", \"Pós-graduação\", \"Status\")\n        self.details_tree = ttk.Treeview(list_frame, columns=columns, show=\"headings\", height=15)\n        \n        # Configurar colunas\n        column_widths = {\n            \"SIAPE\": 100,\n            \"Nome\": 250,\n            \"Carreira\": 100,\n            \"Carga Horária\": 120,\n            \"Pós-graduação\": 130,\n            \"Status\": 100\n        }\n        \n        for col in columns:\n            self.details_tree.heading(col, text=col)\n            self.details_tree.column(col, width=column_widths.get(col, 100))\n        \n        # Scrollbars\n        v_scroll = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.details_tree.yview)\n        h_scroll = ttk.Scrollbar(list_frame, orient=tk.HORIZONTAL, command=self.details_tree.xview)\n        \n        self.details_tree.configure(yscrollcommand=v_scroll.set, xscrollcommand=h_scroll.set)\n        \n        self.details_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\n        v_scroll.grid(row=0, column=1, sticky=(tk.N, tk.S))\n        h_scroll.grid(row=1, column=0, sticky=(tk.W, tk.E))\n        \n        list_frame.grid_rowconfigure(0, weight=1)\n        list_frame.grid_columnconfigure(0, weight=1)\n        \n        # Definir valores padrão dos filtros\n        self.detail_pos_var.set(\"Todos\")\n        self.detail_carreira_var.set(\"Todos\")\n    \n    def load_statistics(self):\n        \"\"\"Carrega as estatísticas\"\"\"\n        try:\n            # Carrega dados dos professores\n            professores = self.teacher_manager.get_teachers_by_school(self.school)\n            \n            if not professores:\n                messagebox.showinfo(\"Informação\", \"Nenhum professor encontrado para esta escola\")\n                return\n            \n            # Calcula estatísticas\n            self.calculate_statistics(professores)\n            \n            # Atualiza gráficos\n            self.update_charts(professores)\n            \n            # Atualiza lista de detalhes\n            self.update_details_list(professores)\n            \n        except Exception as e:\n            logging.error(f\"Erro ao carregar estatísticas: {e}\")\n            messagebox.showerror(\"Erro\", f\"Erro ao carregar estatísticas:\\n{e}\")\n    \n    def calculate_statistics(self, professores):\n        \"\"\"Calcula as estatísticas principais\"\"\"\n        total = len(professores)\n        \n        # Contadores\n        ativos = len([p for p in professores if p.get('status', 'Ativo') == 'Ativo'])\n        prof_40h_de = len([p for p in professores if p.get('carga_horaria') == '40H_DE'])\n        doutorado = len([p for p in professores if p.get('pos_graduacao') == 'DOUTORADO'])\n        mestrado = len([p for p in professores if p.get('pos_graduacao') == 'MESTRADO'])\n        ebtt = len([p for p in professores if p.get('carreira') == 'EBTT'])\n        \n        # Atualiza cards\n        self.total_professores_var.set(str(total))\n        self.professores_ativos_var.set(str(ativos))\n        self.professores_40h_de_var.set(str(prof_40h_de))\n        self.professores_doutorado_var.set(str(doutorado))\n        self.professores_mestrado_var.set(str(mestrado))\n        self.professores_ebtt_var.set(str(ebtt))\n        \n        # Atualiza tabela de distribuição\n        self.update_summary_table(professores, total)\n    \n    def update_summary_table(self, professores, total):\n        \"\"\"Atualiza a tabela de resumo\"\"\"\n        # Limpa tabela\n        for item in self.summary_tree.get_children():\n            self.summary_tree.delete(item)\n        \n        if total == 0:\n            return\n        \n        # Distribuição por pós-graduação\n        pos_counter = Counter([p.get('pos_graduacao', 'Não informado') for p in professores])\n        self.summary_tree.insert('', tk.END, values=(\"PÓS-GRADUAÇÃO\", \"\", \"\"))\n        \n        for pos, count in sorted(pos_counter.items()):\n            percent = (count / total) * 100\n            self.summary_tree.insert('', tk.END, values=(\n                f\"  {pos}\", str(count), f\"{percent:.1f}%\"\n            ))\n        \n        # Distribuição por carga horária\n        carga_counter = Counter([p.get('carga_horaria', 'Não informado') for p in professores])\n        self.summary_tree.insert('', tk.END, values=(\"\", \"\", \"\"))\n        self.summary_tree.insert('', tk.END, values=(\"CARGA HORÁRIA\", \"\", \"\"))\n        \n        for carga, count in sorted(carga_counter.items()):\n            percent = (count / total) * 100\n            self.summary_tree.insert('', tk.END, values=(\n                f\"  {carga}\", str(count), f\"{percent:.1f}%\"\n            ))\n        \n        # Distribuição por carreira\n        carreira_counter = Counter([p.get('carreira', 'Não informado') for p in professores])\n        self.summary_tree.insert('', tk.END, values=(\"\", \"\", \"\"))\n        self.summary_tree.insert('', tk.END, values=(\"CARREIRA\", \"\", \"\"))\n        \n        for carreira, count in sorted(carreira_counter.items()):\n            percent = (count / total) * 100\n            self.summary_tree.insert('', tk.END, values=(\n                f\"  {carreira}\", str(count), f\"{percent:.1f}%\"\n            ))\n    \n    def update_charts(self, professores):\n        \"\"\"Atualiza os gráficos\"\"\"\n        # Limpa container de gráficos\n        for widget in self.charts_container.winfo_children():\n            widget.destroy()\n        \n        if not professores:\n            ttk.Label(\n                self.charts_container,\n                text=\"Nenhum dado disponível para gráficos\",\n                font=(\"Arial\", 12)\n            ).pack(expand=True)\n            return\n        \n        try:\n            # Cria figura com subplots\n            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(12, 8))\n            fig.suptitle(f'Estatísticas - {self.school}', fontsize=16, fontweight='bold')\n            \n            # Gráfico 1: Distribuição por pós-graduação\n            pos_data = Counter([p.get('pos_graduacao', 'Não informado') for p in professores])\n            if pos_data:\n                labels1, values1 = zip(*pos_data.most_common())\n                ax1.pie(values1, labels=labels1, autopct='%1.1f%%', startangle=90)\n                ax1.set_title('Pós-graduação')\n            \n            # Gráfico 2: Distribuição por carga horária\n            carga_data = Counter([p.get('carga_horaria', 'Não informado') for p in professores])\n            if carga_data:\n                labels2, values2 = zip(*carga_data.most_common())\n                ax2.bar(labels2, values2, color=['#ff9999', '#66b3ff', '#99ff99'])\n                ax2.set_title('Carga Horária')\n                ax2.tick_params(axis='x', rotation=45)\n            \n            # Gráfico 3: Distribuição por carreira\n            carreira_data = Counter([p.get('carreira', 'Não informado') for p in professores])\n            if carreira_data:\n                labels3, values3 = zip(*carreira_data.most_common())\n                ax3.pie(values3, labels=labels3, autopct='%1.1f%%', startangle=90)\n                ax3.set_title('Carreira')\n            \n            # Gráfico 4: Status dos professores\n            status_data = Counter([p.get('status', 'Ativo') for p in professores])\n            if status_data:\n                labels4, values4 = zip(*status_data.most_common())\n                colors = ['#90EE90' if l == 'Ativo' else '#FFB6C1' for l in labels4]\n                ax4.bar(labels4, values4, color=colors)\n                ax4.set_title('Status')\n                ax4.tick_params(axis='x', rotation=45)\n            \n            plt.tight_layout()\n            \n            # Integra com Tkinter\n            canvas = FigureCanvasTkAgg(fig, self.charts_container)\n            canvas.draw()\n            canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)\n            \n        except ImportError:\n            # Fallback se matplotlib não estiver disponível\n            ttk.Label(\n                self.charts_container,\n                text=\"Matplotlib não disponível.\\nInstale com: pip install matplotlib\",\n                font=(\"Arial\", 12),\n                justify=tk.CENTER\n            ).pack(expand=True)\n        except Exception as e:\n            logging.error(f\"Erro ao criar gráficos: {e}\")\n            ttk.Label(\n                self.charts_container,\n                text=f\"Erro ao gerar gráficos:\\n{str(e)}\",\n                font=(\"Arial\", 12),\n                justify=tk.CENTER\n            ).pack(expand=True)\n    \n    def update_details_list(self, professores):\n        \"\"\"Atualiza a lista de detalhes\"\"\"\n        # Limpa lista\n        for item in self.details_tree.get_children():\n            self.details_tree.delete(item)\n        \n        # Adiciona professores\n        for professor in sorted(professores, key=lambda x: x.get('nome', '')):\n            self.details_tree.insert('', tk.END, values=(\n                professor.get('siape', ''),\n                professor.get('nome', ''),\n                professor.get('carreira', ''),\n                professor.get('carga_horaria', ''),\n                professor.get('pos_graduacao', ''),\n                professor.get('status', 'Ativo')\n            ))\n    \n    def apply_detail_filters(self):\n        \"\"\"Aplica filtros na lista de detalhes\"\"\"\n        try:\n            professores = self.teacher_manager.get_teachers_by_school(self.school)\n            \n            # Aplica filtros\n            pos_filter = self.detail_pos_var.get()\n            carreira_filter = self.detail_carreira_var.get()\n            \n            if pos_filter and pos_filter != \"Todos\":\n                professores = [p for p in professores if p.get('pos_graduacao') == pos_filter]\n            \n            if carreira_filter and carreira_filter != \"Todos\":\n                professores = [p for p in professores if p.get('carreira') == carreira_filter]\n            \n            # Atualiza lista\n            self.update_details_list(professores)\n            \n        except Exception as e:\n            logging.error(f\"Erro ao aplicar filtros: {e}\")\n            messagebox.showerror(\"Erro\", f\"Erro ao aplicar filtros:\\n{e}\")\n    \n    def export_report(self):\n        \"\"\"Exporta relatório estatístico\"\"\"\n        try:\n            from tkinter import filedialog\n            from datetime import datetime\n            \n            # Seleciona arquivo\n            filename = filedialog.asksaveasfilename(\n                title=\"Exportar Relatório de Estatísticas\",\n                defaultextension=\".txt\",\n                filetypes=[\n                    (\"Arquivos de texto\", \"*.txt\"),\n                    (\"CSV files\", \"*.csv\"),\n                    (\"Todos os arquivos\", \"*.*\")\n                ],\n                initialname=f\"estatisticas_{self.school}_{datetime.now().strftime('%Y%m%d')}.txt\"\n            )\n            \n            if not filename:\n                return\n            \n            # Carrega dados\n            professores = self.teacher_manager.get_teachers_by_school(self.school)\n            \n            # Gera relatório\n            report_content = self.generate_report_content(professores)\n            \n            # Salva arquivo\n            with open(filename, 'w', encoding='utf-8') as f:\n                f.write(report_content)\n            \n            messagebox.showinfo(\"Sucesso\", f\"Relatório exportado para:\\n{filename}\")\n            \n        except Exception as e:\n            logging.error(f\"Erro ao exportar relatório: {e}\")\n            messagebox.showerror(\"Erro\", f\"Erro ao exportar relatório:\\n{e}\")\n    \n    def generate_report_content(self, professores):\n        \"\"\"Gera conteúdo do relatório\"\"\"\n        from datetime import datetime\n        \n        content = f\"\"\"RELATÓRIO DE ESTATÍSTICAS - SISTEMA DIRENS\nEscola: {self.school}\nData: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n\n{'='*60}\n\nRESUMO GERAL:\n- Total de Professores: {len(professores)}\n- Professores Ativos: {len([p for p in professores if p.get('status', 'Ativo') == 'Ativo'])}\n- Professores 40H DE: {len([p for p in professores if p.get('carga_horaria') == '40H_DE'])}\n- Com Doutorado: {len([p for p in professores if p.get('pos_graduacao') == 'DOUTORADO'])}\n- Com Mestrado: {len([p for p in professores if p.get('pos_graduacao') == 'MESTRADO'])}\n- Carreira EBTT: {len([p for p in professores if p.get('carreira') == 'EBTT'])}\n\n{'='*60}\n\nDISTRIBUIÇÃO POR PÓS-GRADUAÇÃO:\n\"\"\"\n        \n        # Adiciona distribuição por pós-graduação\n        pos_counter = Counter([p.get('pos_graduacao', 'Não informado') for p in professores])\n        total = len(professores)\n        \n        for pos, count in sorted(pos_counter.items()):\n            percent = (count / total) * 100 if total > 0 else 0\n            content += f\"- {pos}: {count} ({percent:.1f}%)\\n\"\n        \n        content += f\"\\n{'='*60}\\n\\nDISTRIBUIÇÃO POR CARGA HORÁRIA:\\n\"\n        \n        # Adiciona distribuição por carga horária\n        carga_counter = Counter([p.get('carga_horaria', 'Não informado') for p in professores])\n        \n        for carga, count in sorted(carga_counter.items()):\n            percent = (count / total) * 100 if total > 0 else 0\n            content += f\"- {carga}: {count} ({percent:.1f}%)\\n\"\n        \n        content += f\"\\n{'='*60}\\n\\nDISTRIBUIÇÃO POR CARREIRA:\\n\"\n        \n        # Adiciona distribuição por carreira\n        carreira_counter = Counter([p.get('carreira', 'Não informado') for p in professores])\n        \n        for carreira, count in sorted(carreira_counter.items()):\n            percent = (count / total) * 100 if total > 0 else 0\n            content += f\"- {carreira}: {count} ({percent:.1f}%)\\n\"\n        \n        content += f\"\\n{'='*60}\\n\\nLISTA COMPLETA DE PROFESSORES:\\n\"\n        \n        # Adiciona lista de professores\n        for i, professor in enumerate(sorted(professores, key=lambda x: x.get('nome', '')), 1):\n            content += f\"\\n{i:03d}. {professor.get('nome', '')}\\n\"\n            content += f\"     SIAPE: {professor.get('siape', '')}\\n\"\n            content += f\"     Carreira: {professor.get('carreira', '')}\\n\"\n            content += f\"     Carga Horária: {professor.get('carga_horaria', '')}\\n\"\n            content += f\"     Pós-graduação: {professor.get('pos_graduacao', '')}\\n\"\n            content += f\"     Status: {professor.get('status', 'Ativo')}\\n\"\n        \n        content += f\"\\n{'='*60}\\n\"\n        content += f\"Relatório gerado pelo Sistema DIRENS v1.0\\n\"\n        content += f\"Total de registros: {len(professores)}\\n\"\n        \n        return content\n","size_bytes":21935},"interface/teacher_form.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nFormulário de Professor do Sistema DIRENS\n\"\"\"\n\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nfrom datetime import datetime\nimport logging\n\nfrom core.validators import ValidatorManager\nfrom recursos.constants import CARGAS_HORARIAS, CARREIRAS, POS_GRADUACAO, ESTADOS\n\nclass TeacherFormWindow:\n    \"\"\"Janela do formulário de professor\"\"\"\n    \n    def __init__(self, parent, teacher_manager, school, teacher_data=None, callback=None):\n        \"\"\"Inicializa o formulário\"\"\"\n        self.parent = parent\n        self.teacher_manager = teacher_manager\n        self.school = school\n        self.teacher_data = teacher_data\n        self.callback = callback\n        self.validator = ValidatorManager()\n        \n        # Determina se é edição ou novo\n        self.is_edit = teacher_data is not None\n        \n        # Cria a janela\n        self.window = tk.Toplevel(parent)\n        self.window.title(\"Editar Professor\" if self.is_edit else \"Novo Professor\")\n        self.window.geometry(\"600x700\")\n        self.window.resizable(False, False)\n        \n        # Modal\n        self.window.grab_set()\n        self.window.focus_set()\n        \n        # Centraliza\n        self.center_window()\n        \n        # Cria a interface\n        self.create_widgets()\n        \n        # Preenche dados se for edição\n        if self.is_edit:\n            self.populate_fields()\n    \n    def center_window(self):\n        \"\"\"Centraliza a janela\"\"\"\n        self.window.update_idletasks()\n        \n        parent_x = self.parent.winfo_x()\n        parent_y = self.parent.winfo_y()\n        parent_width = self.parent.winfo_width()\n        parent_height = self.parent.winfo_height()\n        \n        width = 600\n        height = 700\n        \n        x = parent_x + (parent_width - width) // 2\n        y = parent_y + (parent_height - height) // 2\n        \n        self.window.geometry(f\"{width}x{height}+{x}+{y}\")\n    \n    def create_widgets(self):\n        \"\"\"Cria os widgets do formulário\"\"\"\n        # Frame principal com scrollbar\n        canvas = tk.Canvas(self.window)\n        scrollbar = ttk.Scrollbar(self.window, orient=\"vertical\", command=canvas.yview)\n        scrollable_frame = ttk.Frame(canvas)\n        \n        scrollable_frame.bind(\n            \"<Configure>\",\n            lambda e: canvas.configure(scrollregion=canvas.bbox(\"all\"))\n        )\n        \n        canvas.create_window((0, 0), window=scrollable_frame, anchor=\"nw\")\n        canvas.configure(yscrollcommand=scrollbar.set)\n        \n        # Layout\n        canvas.pack(side=\"left\", fill=\"both\", expand=True)\n        scrollbar.pack(side=\"right\", fill=\"y\")\n        \n        # Frame do conteúdo\n        main_frame = ttk.Frame(scrollable_frame, padding=\"20\")\n        main_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Título\n        title_text = \"Editar Professor\" if self.is_edit else \"Novo Professor\"\n        ttk.Label(\n            main_frame,\n            text=title_text,\n            font=(\"Arial\", 16, \"bold\")\n        ).pack(pady=(0, 20))\n        \n        # Dados pessoais\n        self.create_personal_section(main_frame)\n        \n        # Dados profissionais\n        self.create_professional_section(main_frame)\n        \n        # Dados acadêmicos\n        self.create_academic_section(main_frame)\n        \n        # Botões\n        self.create_buttons(main_frame)\n        \n        # Status\n        self.status_var = tk.StringVar()\n        ttk.Label(main_frame, textvariable=self.status_var, foreground=\"red\").pack(pady=10)\n        \n        # Configurar rolagem com mouse\n        def _on_mousewheel(event):\n            canvas.yview_scroll(int(-1*(event.delta/120)), \"units\")\n        \n        canvas.bind_all(\"<MouseWheel>\", _on_mousewheel)\n    \n    def create_personal_section(self, parent):\n        \"\"\"Cria seção de dados pessoais\"\"\"\n        personal_frame = ttk.LabelFrame(parent, text=\"Dados Pessoais\", padding=\"15\")\n        personal_frame.pack(fill=tk.X, pady=(0, 15))\n        personal_frame.grid_columnconfigure(1, weight=1)\n        \n        row = 0\n        \n        # SIAPE\n        ttk.Label(personal_frame, text=\"SIAPE:*\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.siape_var = tk.StringVar()\n        siape_entry = ttk.Entry(personal_frame, textvariable=self.siape_var, width=20)\n        siape_entry.grid(row=row, column=1, sticky=tk.W, pady=5)\n        \n        # Desabilita SIAPE em edição\n        if self.is_edit:\n            siape_entry.config(state='readonly')\n        \n        row += 1\n        \n        # Nome completo\n        ttk.Label(personal_frame, text=\"Nome Completo:*\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.nome_var = tk.StringVar()\n        nome_entry = ttk.Entry(personal_frame, textvariable=self.nome_var, width=50)\n        nome_entry.grid(row=row, column=1, sticky=(tk.W, tk.E), pady=5, columnspan=2)\n        \n        # Bind para converter para maiúscula\n        self.nome_var.trace('w', self.on_name_change)\n        \n        row += 1\n        \n        # CPF\n        ttk.Label(personal_frame, text=\"CPF:*\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.cpf_var = tk.StringVar()\n        ttk.Entry(personal_frame, textvariable=self.cpf_var, width=20).grid(row=row, column=1, sticky=tk.W, pady=5)\n        \n        row += 1\n        \n        # Data de nascimento\n        ttk.Label(personal_frame, text=\"Data Nascimento:*\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.data_nascimento_var = tk.StringVar()\n        data_nasc_entry = ttk.Entry(personal_frame, textvariable=self.data_nascimento_var, width=15)\n        data_nasc_entry.grid(row=row, column=1, sticky=tk.W, pady=5)\n        ttk.Label(personal_frame, text=\"(DD-MM-AAAA)\", foreground=\"gray\").grid(row=row, column=2, sticky=tk.W, padx=5)\n        \n        row += 1\n        \n        # Sexo\n        ttk.Label(personal_frame, text=\"Sexo:*\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.sexo_var = tk.StringVar()\n        sexo_frame = ttk.Frame(personal_frame)\n        sexo_frame.grid(row=row, column=1, sticky=tk.W, pady=5)\n        ttk.Radiobutton(sexo_frame, text=\"Masculino\", variable=self.sexo_var, value=\"M\").pack(side=tk.LEFT)\n        ttk.Radiobutton(sexo_frame, text=\"Feminino\", variable=self.sexo_var, value=\"F\").pack(side=tk.LEFT, padx=10)\n        \n        row += 1\n        \n        # Estado civil\n        ttk.Label(personal_frame, text=\"Estado Civil:\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.estado_civil_var = tk.StringVar()\n        ttk.Combobox(\n            personal_frame,\n            textvariable=self.estado_civil_var,\n            values=[\"Solteiro(a)\", \"Casado(a)\", \"Divorciado(a)\", \"Viúvo(a)\", \"União Estável\"],\n            state=\"readonly\",\n            width=20\n        ).grid(row=row, column=1, sticky=tk.W, pady=5)\n    \n    def create_professional_section(self, parent):\n        \"\"\"Cria seção de dados profissionais\"\"\"\n        prof_frame = ttk.LabelFrame(parent, text=\"Dados Profissionais\", padding=\"15\")\n        prof_frame.pack(fill=tk.X, pady=(0, 15))\n        prof_frame.grid_columnconfigure(1, weight=1)\n        \n        row = 0\n        \n        # Carga horária\n        ttk.Label(prof_frame, text=\"Carga Horária:*\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.carga_horaria_var = tk.StringVar()\n        ttk.Combobox(\n            prof_frame,\n            textvariable=self.carga_horaria_var,\n            values=CARGAS_HORARIAS,\n            state=\"readonly\",\n            width=15\n        ).grid(row=row, column=1, sticky=tk.W, pady=5)\n        \n        row += 1\n        \n        # Carreira\n        ttk.Label(prof_frame, text=\"Carreira:*\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.carreira_var = tk.StringVar()\n        ttk.Combobox(\n            prof_frame,\n            textvariable=self.carreira_var,\n            values=CARREIRAS,\n            state=\"readonly\",\n            width=15\n        ).grid(row=row, column=1, sticky=tk.W, pady=5)\n        \n        row += 1\n        \n        # Data de ingresso\n        ttk.Label(prof_frame, text=\"Data Ingresso:*\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.data_ingresso_var = tk.StringVar()\n        data_ing_entry = ttk.Entry(prof_frame, textvariable=self.data_ingresso_var, width=15)\n        data_ing_entry.grid(row=row, column=1, sticky=tk.W, pady=5)\n        ttk.Label(prof_frame, text=\"(DD-MM-AAAA)\", foreground=\"gray\").grid(row=row, column=2, sticky=tk.W, padx=5)\n        \n        row += 1\n        \n        # Status\n        ttk.Label(prof_frame, text=\"Status:\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.status_prof_var = tk.StringVar()\n        ttk.Combobox(\n            prof_frame,\n            textvariable=self.status_prof_var,\n            values=[\"Ativo\", \"Afastado\", \"Licença\", \"Aposentado\"],\n            state=\"readonly\",\n            width=15\n        ).grid(row=row, column=1, sticky=tk.W, pady=5)\n        \n        row += 1\n        \n        # Área de atuação\n        ttk.Label(prof_frame, text=\"Área de Atuação:\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.area_atuacao_var = tk.StringVar()\n        ttk.Entry(prof_frame, textvariable=self.area_atuacao_var, width=40).grid(row=row, column=1, sticky=(tk.W, tk.E), pady=5)\n    \n    def create_academic_section(self, parent):\n        \"\"\"Cria seção de dados acadêmicos\"\"\"\n        acad_frame = ttk.LabelFrame(parent, text=\"Dados Acadêmicos\", padding=\"15\")\n        acad_frame.pack(fill=tk.X, pady=(0, 15))\n        acad_frame.grid_columnconfigure(1, weight=1)\n        \n        row = 0\n        \n        # Pós-graduação\n        ttk.Label(acad_frame, text=\"Pós-graduação:*\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.pos_graduacao_var = tk.StringVar()\n        ttk.Combobox(\n            acad_frame,\n            textvariable=self.pos_graduacao_var,\n            values=POS_GRADUACAO,\n            state=\"readonly\",\n            width=20\n        ).grid(row=row, column=1, sticky=tk.W, pady=5)\n        \n        row += 1\n        \n        # Graduação\n        ttk.Label(acad_frame, text=\"Graduação:\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.graduacao_var = tk.StringVar()\n        ttk.Entry(acad_frame, textvariable=self.graduacao_var, width=40).grid(row=row, column=1, sticky=(tk.W, tk.E), pady=5)\n        \n        row += 1\n        \n        # Instituição de graduação\n        ttk.Label(acad_frame, text=\"Instituição Graduação:\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.instituicao_grad_var = tk.StringVar()\n        ttk.Entry(acad_frame, textvariable=self.instituicao_grad_var, width=40).grid(row=row, column=1, sticky=(tk.W, tk.E), pady=5)\n        \n        row += 1\n        \n        # Especialização/Mestrado/Doutorado\n        ttk.Label(acad_frame, text=\"Curso Pós-graduação:\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.curso_pos_var = tk.StringVar()\n        ttk.Entry(acad_frame, textvariable=self.curso_pos_var, width=40).grid(row=row, column=1, sticky=(tk.W, tk.E), pady=5)\n        \n        row += 1\n        \n        # Instituição pós\n        ttk.Label(acad_frame, text=\"Instituição Pós:\").grid(row=row, column=0, sticky=tk.W, pady=5)\n        self.instituicao_pos_var = tk.StringVar()\n        ttk.Entry(acad_frame, textvariable=self.instituicao_pos_var, width=40).grid(row=row, column=1, sticky=(tk.W, tk.E), pady=5)\n    \n    def create_buttons(self, parent):\n        \"\"\"Cria os botões do formulário\"\"\"\n        button_frame = ttk.Frame(parent)\n        button_frame.pack(pady=20)\n        \n        # Botão salvar\n        save_text = \"Atualizar\" if self.is_edit else \"Salvar\"\n        ttk.Button(\n            button_frame,\n            text=save_text,\n            command=self.save_teacher,\n            width=15\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Botão cancelar\n        ttk.Button(\n            button_frame,\n            text=\"Cancelar\",\n            command=self.window.destroy,\n            width=15\n        ).pack(side=tk.LEFT, padx=5)\n        \n        # Botão limpar (apenas para novo)\n        if not self.is_edit:\n            ttk.Button(\n                button_frame,\n                text=\"Limpar\",\n                command=self.clear_form,\n                width=15\n            ).pack(side=tk.LEFT, padx=5)\n    \n    def on_name_change(self, *args):\n        \"\"\"Converte nome para maiúscula\"\"\"\n        current = self.nome_var.get()\n        if current != current.upper():\n            # Salva posição do cursor\n            cursor_pos = 0\n            try:\n                # Tenta obter a posição do cursor (pode falhar em alguns casos)\n                widget = self.window.focus_get()\n                if hasattr(widget, 'index'):\n                    cursor_pos = widget.index(tk.INSERT)\n            except:\n                pass\n            \n            # Atualiza valor\n            self.nome_var.set(current.upper())\n            \n            # Restaura posição do cursor\n            try:\n                widget = self.window.focus_get()\n                if hasattr(widget, 'icursor'):\n                    widget.icursor(cursor_pos)\n            except:\n                pass\n    \n    def populate_fields(self):\n        \"\"\"Preenche os campos com dados do professor\"\"\"\n        if not self.teacher_data:\n            return\n        \n        # Dados pessoais\n        self.siape_var.set(self.teacher_data.get('siape', ''))\n        self.nome_var.set(self.teacher_data.get('nome', ''))\n        self.cpf_var.set(self.teacher_data.get('cpf', ''))\n        self.data_nascimento_var.set(self.teacher_data.get('data_nascimento', ''))\n        self.sexo_var.set(self.teacher_data.get('sexo', ''))\n        self.estado_civil_var.set(self.teacher_data.get('estado_civil', ''))\n        \n        # Dados profissionais\n        self.carga_horaria_var.set(self.teacher_data.get('carga_horaria', ''))\n        self.carreira_var.set(self.teacher_data.get('carreira', ''))\n        self.data_ingresso_var.set(self.teacher_data.get('data_ingresso', ''))\n        self.status_prof_var.set(self.teacher_data.get('status', 'Ativo'))\n        self.area_atuacao_var.set(self.teacher_data.get('area_atuacao', ''))\n        \n        # Dados acadêmicos\n        self.pos_graduacao_var.set(self.teacher_data.get('pos_graduacao', ''))\n        self.graduacao_var.set(self.teacher_data.get('graduacao', ''))\n        self.instituicao_grad_var.set(self.teacher_data.get('instituicao_graduacao', ''))\n        self.curso_pos_var.set(self.teacher_data.get('curso_pos', ''))\n        self.instituicao_pos_var.set(self.teacher_data.get('instituicao_pos', ''))\n    \n    def clear_form(self):\n        \"\"\"Limpa todos os campos do formulário\"\"\"\n        # Dados pessoais\n        self.siape_var.set('')\n        self.nome_var.set('')\n        self.cpf_var.set('')\n        self.data_nascimento_var.set('')\n        self.sexo_var.set('')\n        self.estado_civil_var.set('')\n        \n        # Dados profissionais\n        self.carga_horaria_var.set('')\n        self.carreira_var.set('')\n        self.data_ingresso_var.set('')\n        self.status_prof_var.set('Ativo')\n        self.area_atuacao_var.set('')\n        \n        # Dados acadêmicos\n        self.pos_graduacao_var.set('')\n        self.graduacao_var.set('')\n        self.instituicao_grad_var.set('')\n        self.curso_pos_var.set('')\n        self.instituicao_pos_var.set('')\n        \n        self.status_var.set('')\n    \n    def validate_form(self):\n        \"\"\"Valida os dados do formulário\"\"\"\n        errors = []\n        \n        # Campos obrigatórios\n        required_fields = {\n            'SIAPE': self.siape_var.get().strip(),\n            'Nome': self.nome_var.get().strip(),\n            'CPF': self.cpf_var.get().strip(),\n            'Data de Nascimento': self.data_nascimento_var.get().strip(),\n            'Sexo': self.sexo_var.get(),\n            'Carga Horária': self.carga_horaria_var.get(),\n            'Carreira': self.carreira_var.get(),\n            'Data de Ingresso': self.data_ingresso_var.get().strip(),\n            'Pós-graduação': self.pos_graduacao_var.get()\n        }\n        \n        for field, value in required_fields.items():\n            if not value:\n                errors.append(f\"{field} é obrigatório\")\n        \n        if errors:\n            return errors\n        \n        # Validações específicas\n        siape = self.siape_var.get().strip()\n        if not self.validator.validate_siape(siape):\n            errors.append(\"SIAPE deve ter exatamente 7 dígitos numéricos\")\n        \n        cpf = self.cpf_var.get().strip()\n        if not self.validator.validate_cpf(cpf):\n            errors.append(\"CPF inválido\")\n        \n        data_nasc = self.data_nascimento_var.get().strip()\n        if not self.validator.validate_date(data_nasc):\n            errors.append(\"Data de nascimento inválida (use DD-MM-AAAA)\")\n        \n        data_ing = self.data_ingresso_var.get().strip()\n        if not self.validator.validate_date(data_ing):\n            errors.append(\"Data de ingresso inválida (use DD-MM-AAAA)\")\n        \n        # Verifica se SIAPE já existe (apenas para novo professor)\n        if not self.is_edit:\n            if self.teacher_manager.teacher_exists(siape, self.school):\n                errors.append(\"SIAPE já cadastrado nesta escola\")\n        \n        return errors\n    \n    def save_teacher(self):\n        \"\"\"Salva os dados do professor\"\"\"\n        # Valida formulário\n        errors = self.validate_form()\n        if errors:\n            self.status_var.set(errors[0])\n            return\n        \n        # Prepara dados\n        teacher_data = {\n            'siape': self.siape_var.get().strip(),\n            'nome': self.nome_var.get().strip().upper(),\n            'cpf': self.cpf_var.get().strip(),\n            'data_nascimento': self.data_nascimento_var.get().strip(),\n            'sexo': self.sexo_var.get(),\n            'estado_civil': self.estado_civil_var.get(),\n            'carga_horaria': self.carga_horaria_var.get(),\n            'carreira': self.carreira_var.get(),\n            'data_ingresso': self.data_ingresso_var.get().strip(),\n            'status': self.status_prof_var.get() or 'Ativo',\n            'area_atuacao': self.area_atuacao_var.get().strip(),\n            'pos_graduacao': self.pos_graduacao_var.get(),\n            'graduacao': self.graduacao_var.get().strip(),\n            'instituicao_graduacao': self.instituicao_grad_var.get().strip(),\n            'curso_pos': self.curso_pos_var.get().strip(),\n            'instituicao_pos': self.instituicao_pos_var.get().strip(),\n            'escola': self.school,\n            'data_criacao': datetime.now().isoformat() if not self.is_edit else self.teacher_data.get('data_criacao'),\n            'data_atualizacao': datetime.now().isoformat()\n        }\n        \n        try:\n            if self.is_edit:\n                # Atualizar professor existente\n                success = self.teacher_manager.update_teacher(\n                    teacher_data, \n                    self.school,\n                    'usuario_atual'  # TODO: pegar usuário atual\n                )\n            else:\n                # Criar novo professor\n                success = self.teacher_manager.create_teacher(\n                    teacher_data,\n                    'usuario_atual'  # TODO: pegar usuário atual\n                )\n            \n            if success:\n                action = \"atualizado\" if self.is_edit else \"criado\"\n                messagebox.showinfo(\"Sucesso\", f\"Professor {action} com sucesso!\")\n                \n                # Chama callback se definido\n                if self.callback:\n                    self.callback()\n                \n                # Fecha janela\n                self.window.destroy()\n            else:\n                self.status_var.set(\"Erro ao salvar dados do professor\")\n                \n        except Exception as e:\n            logging.error(f\"Erro ao salvar professor: {e}\")\n            self.status_var.set(\"Erro interno do sistema\")\n            messagebox.showerror(\"Erro\", f\"Erro ao salvar professor:\\n{e}\")\n","size_bytes":20048},"recursos/__init__.py":{"content":"\"\"\"\nMódulo de Recursos do Sistema DIRENS\nContém configurações, constantes e utilitários\n\"\"\"\n\n__version__ = \"1.0.0\"\n__author__ = \"Sistema DIRENS\"\n\nfrom .constants import ESCOLAS, CARGAS_HORARIAS, CARREIRAS, POS_GRADUACAO, ESTADOS\nfrom .config import Config\nfrom .utils import format_cpf, format_siape, format_phone, validate_date_format\n\n__all__ = [\n    'ESCOLAS',\n    'CARGAS_HORARIAS', \n    'CARREIRAS',\n    'POS_GRADUACAO',\n    'ESTADOS',\n    'Config',\n    'format_cpf',\n    'format_siape', \n    'format_phone',\n    'validate_date_format'\n]\n","size_bytes":548},"recursos/config.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nConfigurações do Sistema DIRENS\n\"\"\"\n\nimport os\nimport json\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Any\n\nclass Config:\n    \"\"\"Classe de configuração do sistema\"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa as configurações\"\"\"\n        self.config_file = \"data/config.json\"\n        self.default_config = self.get_default_config()\n        self.config = self.load_config()\n        \n        # Cria arquivo de config se não existir\n        if not os.path.exists(self.config_file):\n            self.save_config()\n    \n    def get_default_config(self) -> Dict[str, Any]:\n        \"\"\"Retorna configurações padrão\"\"\"\n        return {\n            \"system\": {\n                \"name\": \"Sistema DIRENS\",\n                \"version\": \"1.0.0\",\n                \"description\": \"Sistema de Controle de Professores DIRENS\",\n                \"author\": \"Sistema DIRENS\",\n                \"created_at\": datetime.now().isoformat()\n            },\n            \"database\": {\n                \"auto_backup\": True,\n                \"backup_interval_hours\": 24,\n                \"max_backups\": 30,\n                \"data_validation\": True\n            },\n            \"ui\": {\n                \"theme\": \"default\",\n                \"language\": \"pt_BR\",\n                \"date_format\": \"DD-MM-AAAA\",\n                \"window_size\": \"1200x800\",\n                \"window_maximized\": True,\n                \"show_splash\": True\n            },\n            \"export\": {\n                \"default_format\": \"csv\",\n                \"include_deleted\": False,\n                \"csv_encoding\": \"utf-8-sig\",\n                \"pdf_page_size\": \"A4\"\n            },\n            \"security\": {\n                \"session_timeout_minutes\": 480,  # 8 horas\n                \"password_min_length\": 6,\n                \"require_password_change\": False,\n                \"lock_after_failed_attempts\": 3\n            },\n            \"logging\": {\n                \"level\": \"INFO\",\n                \"max_file_size_mb\": 10,\n                \"backup_count\": 5,\n                \"log_to_file\": True,\n                \"log_to_console\": True\n            },\n            \"validation\": {\n                \"strict_cpf_validation\": True,\n                \"strict_siape_validation\": True,\n                \"strict_date_validation\": True,\n                \"allow_future_dates\": False,\n                \"min_age_years\": 18,\n                \"max_age_years\": 80\n            },\n            \"features\": {\n                \"enable_statistics\": True,\n                \"enable_exports\": True,\n                \"enable_history\": True,\n                \"enable_backups\": True,\n                \"enable_advanced_search\": True\n            }\n        }\n    \n    def load_config(self) -> Dict[str, Any]:\n        \"\"\"Carrega configurações do arquivo\"\"\"\n        try:\n            if os.path.exists(self.config_file):\n                with open(self.config_file, 'r', encoding='utf-8') as f:\n                    saved_config = json.load(f)\n                \n                # Merge com configurações padrão\n                config = self.default_config.copy()\n                self._deep_merge(config, saved_config)\n                return config\n            else:\n                return self.default_config.copy()\n                \n        except Exception as e:\n            logging.error(f\"Erro ao carregar configurações: {e}\")\n            return self.default_config.copy()\n    \n    def save_config(self) -> bool:\n        \"\"\"Salva configurações no arquivo\"\"\"\n        try:\n            # Garante que o diretório existe\n            config_dir = os.path.dirname(self.config_file)\n            if config_dir and not os.path.exists(config_dir):\n                os.makedirs(config_dir)\n            \n            # Atualiza timestamp\n            self.config[\"system\"][\"last_updated\"] = datetime.now().isoformat()\n            \n            with open(self.config_file, 'w', encoding='utf-8') as f:\n                json.dump(self.config, f, indent=2, ensure_ascii=False, default=str)\n            \n            logging.info(\"Configurações salvas com sucesso\")\n            return True\n            \n        except Exception as e:\n            logging.error(f\"Erro ao salvar configurações: {e}\")\n            return False\n    \n    def _deep_merge(self, target: Dict, source: Dict) -> None:\n        \"\"\"Faz merge profundo de dicionários\"\"\"\n        for key, value in source.items():\n            if key in target and isinstance(target[key], dict) and isinstance(value, dict):\n                self._deep_merge(target[key], value)\n            else:\n                target[key] = value\n    \n    def get(self, section: str, key: str = None, default: Any = None) -> Any:\n        \"\"\"Obtém valor de configuração\"\"\"\n        try:\n            if key is None:\n                return self.config.get(section, default)\n            \n            section_config = self.config.get(section, {})\n            return section_config.get(key, default)\n            \n        except Exception as e:\n            logging.error(f\"Erro ao obter configuração {section}.{key}: {e}\")\n            return default\n    \n    def set(self, section: str, key: str, value: Any) -> bool:\n        \"\"\"Define valor de configuração\"\"\"\n        try:\n            if section not in self.config:\n                self.config[section] = {}\n            \n            self.config[section][key] = value\n            return self.save_config()\n            \n        except Exception as e:\n            logging.error(f\"Erro ao definir configuração {section}.{key}: {e}\")\n            return False\n    \n    def reset_to_defaults(self) -> bool:\n        \"\"\"Reseta configurações para padrão\"\"\"\n        try:\n            self.config = self.default_config.copy()\n            return self.save_config()\n        except Exception as e:\n            logging.error(f\"Erro ao resetar configurações: {e}\")\n            return False\n    \n    def validate_config(self) -> Dict[str, Any]:\n        \"\"\"Valida configurações atuais\"\"\"\n        issues = []\n        warnings = []\n        \n        try:\n            # Valida seções obrigatórias\n            required_sections = [\"system\", \"database\", \"ui\", \"export\", \"security\"]\n            for section in required_sections:\n                if section not in self.config:\n                    issues.append(f\"Seção obrigatória ausente: {section}\")\n            \n            # Valida valores específicos\n            if self.get(\"security\", \"password_min_length\", 6) < 4:\n                warnings.append(\"Tamanho mínimo da senha muito baixo\")\n            \n            if self.get(\"database\", \"max_backups\", 30) < 5:\n                warnings.append(\"Número mínimo de backups muito baixo\")\n            \n            session_timeout = self.get(\"security\", \"session_timeout_minutes\", 480)\n            if session_timeout < 30:\n                warnings.append(\"Timeout de sessão muito baixo\")\n            elif session_timeout > 1440:  # 24 horas\n                warnings.append(\"Timeout de sessão muito alto\")\n            \n            return {\n                \"valid\": len(issues) == 0,\n                \"issues\": issues,\n                \"warnings\": warnings\n            }\n            \n        except Exception as e:\n            logging.error(f\"Erro na validação de configurações: {e}\")\n            return {\n                \"valid\": False,\n                \"issues\": [f\"Erro na validação: {e}\"],\n                \"warnings\": []\n            }\n    \n    def export_config(self, filepath: str) -> bool:\n        \"\"\"Exporta configurações para arquivo\"\"\"\n        try:\n            export_data = {\n                \"exported_at\": datetime.now().isoformat(),\n                \"system_info\": {\n                    \"name\": self.get(\"system\", \"name\"),\n                    \"version\": self.get(\"system\", \"version\")\n                },\n                \"config\": self.config\n            }\n            \n            with open(filepath, 'w', encoding='utf-8') as f:\n                json.dump(export_data, f, indent=2, ensure_ascii=False, default=str)\n            \n            logging.info(f\"Configurações exportadas para: {filepath}\")\n            return True\n            \n        except Exception as e:\n            logging.error(f\"Erro ao exportar configurações: {e}\")\n            return False\n    \n    def import_config(self, filepath: str) -> bool:\n        \"\"\"Importa configurações de arquivo\"\"\"\n        try:\n            if not os.path.exists(filepath):\n                logging.error(f\"Arquivo de configuração não encontrado: {filepath}\")\n                return False\n            \n            with open(filepath, 'r', encoding='utf-8') as f:\n                import_data = json.load(f)\n            \n            # Valida estrutura\n            if \"config\" not in import_data:\n                logging.error(\"Estrutura de configuração inválida\")\n                return False\n            \n            # Faz backup da configuração atual\n            backup_file = f\"{self.config_file}.backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n            if os.path.exists(self.config_file):\n                import shutil\n                shutil.copy2(self.config_file, backup_file)\n            \n            # Importa nova configuração\n            imported_config = import_data[\"config\"]\n            self.config = self.default_config.copy()\n            self._deep_merge(self.config, imported_config)\n            \n            # Valida configuração importada\n            validation = self.validate_config()\n            if not validation[\"valid\"]:\n                logging.error(\"Configuração importada é inválida\")\n                return False\n            \n            return self.save_config()\n            \n        except Exception as e:\n            logging.error(f\"Erro ao importar configurações: {e}\")\n            return False\n    \n    def get_database_config(self) -> Dict[str, Any]:\n        \"\"\"Retorna configurações de banco de dados\"\"\"\n        return self.config.get(\"database\", {})\n    \n    def get_ui_config(self) -> Dict[str, Any]:\n        \"\"\"Retorna configurações de interface\"\"\"\n        return self.config.get(\"ui\", {})\n    \n    def get_security_config(self) -> Dict[str, Any]:\n        \"\"\"Retorna configurações de segurança\"\"\"\n        return self.config.get(\"security\", {})\n    \n    def get_export_config(self) -> Dict[str, Any]:\n        \"\"\"Retorna configurações de exportação\"\"\"\n        return self.config.get(\"export\", {})\n    \n    def get_logging_config(self) -> Dict[str, Any]:\n        \"\"\"Retorna configurações de logging\"\"\"\n        return self.config.get(\"logging\", {})\n    \n    def get_validation_config(self) -> Dict[str, Any]:\n        \"\"\"Retorna configurações de validação\"\"\"\n        return self.config.get(\"validation\", {})\n    \n    def get_features_config(self) -> Dict[str, Any]:\n        \"\"\"Retorna configurações de funcionalidades\"\"\"\n        return self.config.get(\"features\", {})\n    \n    def is_feature_enabled(self, feature_name: str) -> bool:\n        \"\"\"Verifica se uma funcionalidade está habilitada\"\"\"\n        return self.get(\"features\", feature_name, True)\n    \n    def toggle_feature(self, feature_name: str) -> bool:\n        \"\"\"Alterna uma funcionalidade\"\"\"\n        current_value = self.is_feature_enabled(feature_name)\n        return self.set(\"features\", feature_name, not current_value)\n","size_bytes":11328},"recursos/constants.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nConstantes do Sistema DIRENS\n\"\"\"\n\n# Escolas subordinadas à DIRENS\nESCOLAS = {\n    \"IFPE - Campus Recife\": {\n        \"codigo\": \"PE01\",\n        \"endereco\": \"Av. Prof. Luís Freire, 500 - Cidade Universitária\",\n        \"cidade\": \"Recife\",\n        \"estado\": \"PE\",\n        \"telefone\": \"(81) 2125-1600\"\n    },\n    \"IFPE - Campus Olinda\": {\n        \"codigo\": \"PE02\", \n        \"endereco\": \"Rua Márcio Canuto, 210 - Nossa Senhora do Amparo\",\n        \"cidade\": \"Olinda\",\n        \"estado\": \"PE\",\n        \"telefone\": \"(81) 3412-5000\"\n    },\n    \"IFPE - Campus Jaboatão\": {\n        \"codigo\": \"PE03\",\n        \"endereco\": \"BR-104, Km 56 - Sucupira\",\n        \"cidade\": \"Jaboatão dos Guararapes\", \n        \"estado\": \"PE\",\n        \"telefone\": \"(81) 3186-5000\"\n    },\n    \"IFPE - Campus Vitória\": {\n        \"codigo\": \"PE04\",\n        \"endereco\": \"Rua Sebastião Cavalcanti, 158 - Vitória de Santo Antão\",\n        \"cidade\": \"Vitória de Santo Antão\",\n        \"estado\": \"PE\", \n        \"telefone\": \"(81) 3523-8100\"\n    },\n    \"IFPE - Campus Palmares\": {\n        \"codigo\": \"PE05\",\n        \"endereco\": \"BR-101 Sul, Km 83 - Engenho Noruega\",\n        \"cidade\": \"Palmares\",\n        \"estado\": \"PE\",\n        \"telefone\": \"(81) 3661-9500\"\n    },\n    \"IFPE - Campus Garanhuns\": {\n        \"codigo\": \"PE06\",\n        \"endereco\": \"Av. Rui Barbosa, s/n - Vila Kennedy\", \n        \"cidade\": \"Garanhuns\",\n        \"estado\": \"PE\",\n        \"telefone\": \"(87) 3761-4304\"\n    },\n    \"IFPE - Campus Caruaru\": {\n        \"codigo\": \"PE07\",\n        \"endereco\": \"Rodovia BR-104, Km 59,2 - Fazenda Riachão\",\n        \"cidade\": \"Caruaru\",\n        \"estado\": \"PE\",\n        \"telefone\": \"(81) 3706-8700\"\n    },\n    \"IFPE - Campus Pesqueira\": {\n        \"codigo\": \"PE08\",\n        \"endereco\": \"Rodovia BR-232, Km 214 - Prado\",\n        \"cidade\": \"Pesqueira\", \n        \"estado\": \"PE\",\n        \"telefone\": \"(87) 3835-1929\"\n    },\n    \"IFPE - Campus Cabo\": {\n        \"codigo\": \"PE09\",\n        \"endereco\": \"Av. Beira Rio, s/n - Vila Velha\",\n        \"cidade\": \"Cabo de Santo Agostinho\",\n        \"estado\": \"PE\",\n        \"telefone\": \"(81) 3518-8900\"\n    },\n    \"IFPE - Campus Barreiros\": {\n        \"codigo\": \"PE10\",\n        \"endereco\": \"Fazenda Sapé, s/n - Zona Rural\",\n        \"cidade\": \"Barreiros\",\n        \"estado\": \"PE\", \n        \"telefone\": \"(81) 3675-1400\"\n    },\n    \"IFPE - Campus Belo Jardim\": {\n        \"codigo\": \"PE11\",\n        \"endereco\": \"Av. Sebastião Rodrigues da Costa, s/n - São Pedro\",\n        \"cidade\": \"Belo Jardim\",\n        \"estado\": \"PE\",\n        \"telefone\": \"(81) 3726-4900\"\n    },\n    \"IFPE - Campus Afogados da Ingazeira\": {\n        \"codigo\": \"PE12\",\n        \"endereco\": \"Rodovia PE-366, s/n - DNER\",\n        \"cidade\": \"Afogados da Ingazeira\",\n        \"estado\": \"PE\",\n        \"telefone\": \"(87) 3838-2100\"\n    },\n    \"IFPE - Campus Abreu e Lima\": {\n        \"codigo\": \"PE13\",\n        \"endereco\": \"Rua Venâncio João da Costa, s/n - Fosfato\",\n        \"cidade\": \"Abreu e Lima\", \n        \"estado\": \"PE\",\n        \"telefone\": \"(81) 3362-7777\"\n    },\n    \"IFPE - Campus Ipojuca\": {\n        \"codigo\": \"PE14\",\n        \"endereco\": \"Rodovia PE-060, s/n - Ipojuca\",\n        \"cidade\": \"Ipojuca\",\n        \"estado\": \"PE\",\n        \"telefone\": \"(81) 3511-4100\"\n    },\n    \"IFPE - Campus Igarassu\": {\n        \"codigo\": \"PE15\",\n        \"endereco\": \"Rodovia PE-015, Km 12 - Cruz de Rebouças\",\n        \"cidade\": \"Igarassu\",\n        \"estado\": \"PE\",\n        \"telefone\": \"(81) 3543-3600\"\n    }\n}\n\n# Cargas horárias disponíveis\nCARGAS_HORARIAS = [\n    \"20H\",\n    \"40H\", \n    \"40H_DE\"  # Dedicação Exclusiva\n]\n\n# Carreiras docentes\nCARREIRAS = [\n    \"MS\",    # Magistério Superior\n    \"EBTT\"   # Ensino Básico, Técnico e Tecnológico\n]\n\n# Níveis de pós-graduação\nPOS_GRADUACAO = [\n    \"GRADUAÇÃO\",\n    \"ESPECIALIZAÇÃO\", \n    \"MESTRADO\",\n    \"DOUTORADO\"\n]\n\n# Estados brasileiros\nESTADOS = [\n    \"AC\", \"AL\", \"AP\", \"AM\", \"BA\", \"CE\", \"DF\", \"ES\", \"GO\", \"MA\",\n    \"MT\", \"MS\", \"MG\", \"PA\", \"PB\", \"PR\", \"PE\", \"PI\", \"RJ\", \"RN\", \n    \"RS\", \"RO\", \"RR\", \"SC\", \"SP\", \"SE\", \"TO\"\n]\n\n# Estados com nomes completos\nESTADOS_COMPLETOS = {\n    \"AC\": \"Acre\",\n    \"AL\": \"Alagoas\", \n    \"AP\": \"Amapá\",\n    \"AM\": \"Amazonas\",\n    \"BA\": \"Bahia\",\n    \"CE\": \"Ceará\",\n    \"DF\": \"Distrito Federal\",\n    \"ES\": \"Espírito Santo\",\n    \"GO\": \"Goiás\",\n    \"MA\": \"Maranhão\",\n    \"MT\": \"Mato Grosso\", \n    \"MS\": \"Mato Grosso do Sul\",\n    \"MG\": \"Minas Gerais\",\n    \"PA\": \"Pará\",\n    \"PB\": \"Paraíba\",\n    \"PR\": \"Paraná\",\n    \"PE\": \"Pernambuco\",\n    \"PI\": \"Piauí\",\n    \"RJ\": \"Rio de Janeiro\",\n    \"RN\": \"Rio Grande do Norte\",\n    \"RS\": \"Rio Grande do Sul\",\n    \"RO\": \"Rondônia\",\n    \"RR\": \"Roraima\", \n    \"SC\": \"Santa Catarina\",\n    \"SP\": \"São Paulo\",\n    \"SE\": \"Sergipe\",\n    \"TO\": \"Tocantins\"\n}\n\n# Áreas do conhecimento (CNPQ)\nAREAS_CONHECIMENTO = [\n    \"Ciências Exatas e da Terra\",\n    \"Ciências Biológicas\",\n    \"Engenharias\",\n    \"Ciências da Saúde\", \n    \"Ciências Agrárias\",\n    \"Ciências Sociais Aplicadas\",\n    \"Ciências Humanas\",\n    \"Linguística, Letras e Artes\",\n    \"Multidisciplinar\"\n]\n\n# Tipos de vínculo\nTIPOS_VINCULO = [\n    \"Efetivo\",\n    \"Substituto\",\n    \"Temporário\",\n    \"Visitante\"\n]\n\n# Status do professor\nSTATUS_PROFESSOR = [\n    \"Ativo\",\n    \"Afastado\",\n    \"Licença Médica\",\n    \"Licença Maternidade\", \n    \"Licença Paternidade\",\n    \"Licença Capacitação\",\n    \"Cedido\",\n    \"Aposentado\",\n    \"Exonerado\",\n    \"Falecido\"\n]\n\n# Regimes de trabalho\nREGIMES_TRABALHO = [\n    \"RDE\",  # Regime de Dedicação Exclusiva\n    \"RT\",   # Regime de Tempo Integral \n    \"TP\"    # Regime de Tempo Parcial\n]\n\n# Classes da carreira docente\nCLASSES_DOCENTE = {\n    \"EBTT\": [\"DI\", \"DII\", \"DIII\", \"DIV\", \"DV\"],\n    \"MS\": [\"Adjunto\", \"Associado\", \"Titular\"]\n}\n\n# Níveis por classe EBTT\nNIVEIS_EBTT = [\"1\", \"2\", \"3\", \"4\"]\n\n# Níveis por classe MS\nNIVEIS_MS = [\"1\", \"2\", \"3\", \"4\"]\n\n# Formatos de data aceitos\nDATE_FORMATS = [\n    \"%d-%m-%Y\",\n    \"%d/%m/%Y\", \n    \"%Y-%m-%d\",\n    \"%d.%m.%Y\"\n]\n\n# Expressões regulares comuns\nREGEX_PATTERNS = {\n    \"cpf\": r\"^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$\",\n    \"siape\": r\"^\\d{7}$\",\n    \"telefone\": r\"^\\(\\d{2}\\)\\s\\d{4,5}-\\d{4}$\",\n    \"cep\": r\"^\\d{5}-\\d{3}$\",\n    \"email\": r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n}\n\n# Configurações de interface\nUI_CONFIG = {\n    \"colors\": {\n        \"primary\": \"#1f4e79\",\n        \"secondary\": \"#7fa6d3\", \n        \"success\": \"#28a745\",\n        \"warning\": \"#ffc107\",\n        \"danger\": \"#dc3545\",\n        \"info\": \"#17a2b8\"\n    },\n    \"fonts\": {\n        \"default\": (\"Segoe UI\", 9),\n        \"header\": (\"Segoe UI\", 12, \"bold\"),\n        \"title\": (\"Segoe UI\", 14, \"bold\")\n    }\n}\n\n# Mensagens padrão\nMESSAGES = {\n    \"success\": {\n        \"save\": \"Dados salvos com sucesso!\",\n        \"delete\": \"Registro excluído com sucesso!\",\n        \"export\": \"Dados exportados com sucesso!\",\n        \"backup\": \"Backup criado com sucesso!\",\n        \"restore\": \"Backup restaurado com sucesso!\"\n    },\n    \"error\": {\n        \"save\": \"Erro ao salvar dados\",\n        \"delete\": \"Erro ao excluir registro\",\n        \"export\": \"Erro ao exportar dados\", \n        \"backup\": \"Erro ao criar backup\",\n        \"restore\": \"Erro ao restaurar backup\",\n        \"validation\": \"Dados inválidos\"\n    },\n    \"warning\": {\n        \"unsaved_changes\": \"Há alterações não salvas. Deseja continuar?\",\n        \"delete_confirm\": \"Deseja realmente excluir este registro?\",\n        \"overwrite_confirm\": \"Arquivo já existe. Deseja sobrescrever?\"\n    },\n    \"info\": {\n        \"loading\": \"Carregando dados...\",\n        \"processing\": \"Processando...\",\n        \"no_data\": \"Nenhum dado encontrado\",\n        \"empty_list\": \"Lista vazia\"\n    }\n}\n\n# Constantes do sistema\nSYSTEM_CONFIG = {\n    \"name\": \"Sistema DIRENS\", \n    \"version\": \"1.0.0\",\n    \"author\": \"Sistema DIRENS\",\n    \"description\": \"Sistema de Controle de Professores DIRENS\",\n    \"max_file_size_mb\": 50,\n    \"supported_image_formats\": [\".jpg\", \".jpeg\", \".png\", \".gif\", \".bmp\"],\n    \"supported_document_formats\": [\".pdf\", \".doc\", \".docx\", \".txt\"],\n    \"date_format_display\": \"%d/%m/%Y\",\n    \"datetime_format_display\": \"%d/%m/%Y %H:%M:%S\",\n    \"backup_retention_days\": 90,\n    \"session_timeout_minutes\": 480\n}\n\n# Validações específicas\nVALIDATION_RULES = {\n    \"siape\": {\n        \"length\": 7,\n        \"type\": \"numeric\",\n        \"required\": True\n    },\n    \"cpf\": {\n        \"length\": 11,\n        \"type\": \"numeric\",\n        \"required\": True,\n        \"validate_digits\": True\n    },\n    \"nome\": {\n        \"min_length\": 2,\n        \"max_length\": 100, \n        \"type\": \"text\",\n        \"required\": True,\n        \"uppercase\": True\n    },\n    \"data_nascimento\": {\n        \"format\": \"DD-MM-YYYY\",\n        \"min_age\": 18,\n        \"max_age\": 80,\n        \"required\": True\n    },\n    \"data_ingresso\": {\n        \"format\": \"DD-MM-YYYY\",\n        \"not_future\": True,\n        \"required\": True\n    }\n}\n","size_bytes":8844},"recursos/utils.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\nUtilitários do Sistema DIRENS\n\"\"\"\n\nimport re\nimport os\nimport sys\nimport json\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Optional, List, Dict, Any, Union\nimport tkinter as tk\nfrom tkinter import messagebox\n\ndef format_cpf(cpf: str) -> str:\n    \"\"\"Formata CPF no padrão XXX.XXX.XXX-XX\"\"\"\n    if not cpf:\n        return \"\"\n    \n    # Remove caracteres não numéricos\n    cpf_clean = re.sub(r'\\D', '', str(cpf))\n    \n    # Adiciona formatação se tem 11 dígitos\n    if len(cpf_clean) == 11:\n        return f\"{cpf_clean[:3]}.{cpf_clean[3:6]}.{cpf_clean[6:9]}-{cpf_clean[9:]}\"\n    \n    return cpf_clean\n\ndef format_siape(siape: str) -> str:\n    \"\"\"Formata SIAPE removendo caracteres não numéricos\"\"\"\n    if not siape:\n        return \"\"\n    \n    # Remove caracteres não numéricos\n    siape_clean = re.sub(r'\\D', '', str(siape))\n    \n    # Retorna apenas se tem 7 dígitos\n    if len(siape_clean) == 7:\n        return siape_clean\n    \n    return siape_clean\n\ndef format_phone(phone: str) -> str:\n    \"\"\"Formata telefone no padrão (XX) XXXX-XXXX ou (XX) XXXXX-XXXX\"\"\"\n    if not phone:\n        return \"\"\n    \n    # Remove caracteres não numéricos  \n    phone_clean = re.sub(r'\\D', '', str(phone))\n    \n    # Formata conforme número de dígitos\n    if len(phone_clean) == 10:\n        return f\"({phone_clean[:2]}) {phone_clean[2:6]}-{phone_clean[6:]}\"\n    elif len(phone_clean) == 11:\n        return f\"({phone_clean[:2]}) {phone_clean[2:7]}-{phone_clean[7:]}\"\n    \n    return phone_clean\n\ndef format_cep(cep: str) -> str:\n    \"\"\"Formata CEP no padrão XXXXX-XXX\"\"\"\n    if not cep:\n        return \"\"\n    \n    # Remove caracteres não numéricos\n    cep_clean = re.sub(r'\\D', '', str(cep))\n    \n    # Adiciona formatação se tem 8 dígitos\n    if len(cep_clean) == 8:\n        return f\"{cep_clean[:5]}-{cep_clean[5:]}\"\n    \n    return cep_clean\n\ndef validate_date_format(date_str: str, format_str: str = \"%d-%m-%Y\") -> bool:\n    \"\"\"Valida formato de data\"\"\"\n    if not date_str:\n        return False\n    \n    try:\n        datetime.strptime(date_str, format_str)\n        return True\n    except ValueError:\n        return False\n\ndef convert_date_format(date_str: str, input_format: str = \"%d-%m-%Y\", \n                       output_format: str = \"%Y-%m-%d\") -> Optional[str]:\n    \"\"\"Converte data entre formatos\"\"\"\n    try:\n        date_obj = datetime.strptime(date_str, input_format)\n        return date_obj.strftime(output_format)\n    except ValueError:\n        return None\n\ndef calculate_age(birth_date: str, reference_date: Optional[str] = None) -> Optional[int]:\n    \"\"\"Calcula idade a partir da data de nascimento\"\"\"\n    try:\n        birth = datetime.strptime(birth_date, \"%d-%m-%Y\")\n        \n        if reference_date:\n            ref = datetime.strptime(reference_date, \"%d-%m-%Y\")\n        else:\n            ref = datetime.now()\n        \n        age = ref.year - birth.year\n        \n        # Ajusta se ainda não fez aniversário no ano\n        if ref.month < birth.month or (ref.month == birth.month and ref.day < birth.day):\n            age -= 1\n        \n        return age\n        \n    except ValueError:\n        return None\n\ndef sanitize_filename(filename: str) -> str:\n    \"\"\"Remove caracteres inválidos de nome de arquivo\"\"\"\n    # Caracteres não permitidos em nomes de arquivo\n    invalid_chars = r'[<>:\"/\\\\|?*]'\n    \n    # Remove caracteres inválidos\n    clean_filename = re.sub(invalid_chars, '_', filename)\n    \n    # Remove pontos no final\n    clean_filename = clean_filename.rstrip('.')\n    \n    # Limita tamanho\n    if len(clean_filename) > 200:\n        clean_filename = clean_filename[:200]\n    \n    return clean_filename\n\ndef format_file_size(size_bytes: int) -> str:\n    \"\"\"Formata tamanho de arquivo em formato legível\"\"\"\n    if size_bytes == 0:\n        return \"0 B\"\n    \n    size_names = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\"]\n    import math\n    \n    i = int(math.floor(math.log(size_bytes, 1024)))\n    p = math.pow(1024, i)\n    s = round(size_bytes / p, 2)\n    \n    return f\"{s} {size_names[i]}\"\n\ndef get_system_info() -> Dict[str, Any]:\n    \"\"\"Retorna informações do sistema\"\"\"\n    import platform\n    \n    return {\n        \"platform\": platform.system(),\n        \"platform_release\": platform.release(),\n        \"platform_version\": platform.version(),\n        \"architecture\": platform.machine(),\n        \"processor\": platform.processor(),\n        \"python_version\": platform.python_version(),\n        \"python_implementation\": platform.python_implementation()\n    }\n\ndef center_window(window: tk.Tk, width: int, height: int) -> None:\n    \"\"\"Centraliza janela na tela\"\"\"\n    # Obtém dimensões da tela\n    screen_width = window.winfo_screenwidth()\n    screen_height = window.winfo_screenheight()\n    \n    # Calcula posição central\n    x = (screen_width - width) // 2\n    y = (screen_height - height) // 2\n    \n    # Define geometria\n    window.geometry(f\"{width}x{height}+{x}+{y}\")\n\ndef show_error(title: str, message: str, parent: Optional[tk.Tk] = None) -> None:\n    \"\"\"Mostra diálogo de erro\"\"\"\n    messagebox.showerror(title, message, parent=parent)\n\ndef show_warning(title: str, message: str, parent: Optional[tk.Tk] = None) -> None:\n    \"\"\"Mostra diálogo de aviso\"\"\"\n    messagebox.showwarning(title, message, parent=parent)\n\ndef show_info(title: str, message: str, parent: Optional[tk.Tk] = None) -> None:\n    \"\"\"Mostra diálogo de informação\"\"\"\n    messagebox.showinfo(title, message, parent=parent)\n\ndef confirm_dialog(title: str, message: str, parent: Optional[tk.Tk] = None) -> bool:\n    \"\"\"Mostra diálogo de confirmação\"\"\"\n    return messagebox.askyesno(title, message, parent=parent)\n\ndef create_directory_if_not_exists(directory: str) -> bool:\n    \"\"\"Cria diretório se não existir\"\"\"\n    try:\n        if not os.path.exists(directory):\n            os.makedirs(directory)\n        return True\n    except Exception as e:\n        logging.error(f\"Erro ao criar diretório {directory}: {e}\")\n        return False\n\ndef safe_remove_file(filepath: str) -> bool:\n    \"\"\"Remove arquivo de forma segura\"\"\"\n    try:\n        if os.path.exists(filepath):\n            os.remove(filepath)\n        return True\n    except Exception as e:\n        logging.error(f\"Erro ao remover arquivo {filepath}: {e}\")\n        return False\n\ndef backup_file(filepath: str, backup_dir: str = \"backups\") -> Optional[str]:\n    \"\"\"Cria backup de um arquivo\"\"\"\n    try:\n        if not os.path.exists(filepath):\n            return None\n        \n        # Cria diretório de backup\n        create_directory_if_not_exists(backup_dir)\n        \n        # Nome do backup com timestamp\n        filename = os.path.basename(filepath)\n        name, ext = os.path.splitext(filename)\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        backup_filename = f\"{name}_backup_{timestamp}{ext}\"\n        backup_path = os.path.join(backup_dir, backup_filename)\n        \n        # Copia arquivo\n        import shutil\n        shutil.copy2(filepath, backup_path)\n        \n        return backup_path\n        \n    except Exception as e:\n        logging.error(f\"Erro ao fazer backup de {filepath}: {e}\")\n        return None\n\ndef load_json_file(filepath: str, default: Any = None) -> Any:\n    \"\"\"Carrega arquivo JSON de forma segura\"\"\"\n    try:\n        if os.path.exists(filepath):\n            with open(filepath, 'r', encoding='utf-8') as f:\n                return json.load(f)\n        return default or {}\n    except Exception as e:\n        logging.error(f\"Erro ao carregar JSON {filepath}: {e}\")\n        return default or {}\n\ndef save_json_file(filepath: str, data: Any) -> bool:\n    \"\"\"Salva arquivo JSON de forma segura\"\"\"\n    try:\n        # Cria diretório se não existir\n        directory = os.path.dirname(filepath)\n        if directory:\n            create_directory_if_not_exists(directory)\n        \n        with open(filepath, 'w', encoding='utf-8') as f:\n            json.dump(data, f, indent=2, ensure_ascii=False, default=str)\n        return True\n    except Exception as e:\n        logging.error(f\"Erro ao salvar JSON {filepath}: {e}\")\n        return False\n\ndef validate_required_fields(data: Dict[str, Any], required_fields: List[str]) -> List[str]:\n    \"\"\"Valida campos obrigatórios\"\"\"\n    missing_fields = []\n    \n    for field in required_fields:\n        value = data.get(field)\n        if not value or str(value).strip() == '':\n            missing_fields.append(field)\n    \n    return missing_fields\n\ndef clean_string(text: str, remove_accents: bool = False) -> str:\n    \"\"\"Limpa string removendo caracteres especiais\"\"\"\n    if not text:\n        return \"\"\n    \n    # Remove espaços extras\n    cleaned = re.sub(r'\\s+', ' ', str(text).strip())\n    \n    # Remove acentos se solicitado\n    if remove_accents:\n        import unicodedata\n        normalized = unicodedata.normalize('NFD', cleaned)\n        cleaned = ''.join(c for c in normalized if unicodedata.category(c) != 'Mn')\n    \n    return cleaned\n\ndef generate_unique_id() -> str:\n    \"\"\"Gera ID único baseado em timestamp\"\"\"\n    return datetime.now().strftime(\"%Y%m%d_%H%M%S_%f\")[:-3]\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"Valida formato de email\"\"\"\n    if not email:\n        return False\n    \n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n\ndef mask_sensitive_data(text: str, mask_char: str = '*', \n                       visible_start: int = 2, visible_end: int = 2) -> str:\n    \"\"\"Mascara dados sensíveis\"\"\"\n    if not text or len(text) <= visible_start + visible_end:\n        return mask_char * len(text) if text else \"\"\n    \n    start = text[:visible_start]\n    end = text[-visible_end:] if visible_end > 0 else \"\"\n    middle = mask_char * (len(text) - visible_start - visible_end)\n    \n    return f\"{start}{middle}{end}\"\n\ndef get_resource_path(relative_path: str) -> str:\n    \"\"\"Obtém caminho absoluto para recurso (útil para executáveis)\"\"\"\n    try:\n        # PyInstaller cria uma pasta temp e armazena o caminho em _MEIPASS\n        base_path = sys._MEIPASS\n    except Exception:\n        base_path = os.path.abspath(\".\")\n    \n    return os.path.join(base_path, relative_path)\n\ndef setup_logging(log_level: str = \"INFO\", log_file: str = None) -> None:\n    \"\"\"Configura sistema de logging\"\"\"\n    level = getattr(logging, log_level.upper(), logging.INFO)\n    \n    handlers = [logging.StreamHandler()]\n    \n    if log_file:\n        # Cria diretório de logs\n        log_dir = os.path.dirname(log_file)\n        if log_dir:\n            create_directory_if_not_exists(log_dir)\n        \n        handlers.append(logging.FileHandler(log_file, encoding='utf-8'))\n    \n    logging.basicConfig(\n        level=level,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        handlers=handlers\n    )\n\ndef benchmark_function(func, *args, **kwargs) -> tuple:\n    \"\"\"Mede tempo de execução de uma função\"\"\"\n    import time\n    \n    start_time = time.time()\n    result = func(*args, **kwargs)\n    end_time = time.time()\n    \n    execution_time = end_time - start_time\n    return result, execution_time\n\ndef retry_operation(func, max_attempts: int = 3, delay: float = 1.0, \n                   exceptions: tuple = (Exception,)) -> Any:\n    \"\"\"Repete operação em caso de falha\"\"\"\n    import time\n    \n    for attempt in range(max_attempts):\n        try:\n            return func()\n        except exceptions as e:\n            if attempt == max_attempts - 1:\n                raise e\n            \n            logging.warning(f\"Tentativa {attempt + 1} falhou: {e}. Tentando novamente em {delay}s...\")\n            time.sleep(delay)\n            delay *= 2  # Backoff exponencial\n\ndef parse_version(version_string: str) -> tuple:\n    \"\"\"Parse string de versão para tupla comparável\"\"\"\n    try:\n        return tuple(map(int, version_string.split('.')))\n    except ValueError:\n        return (0, 0, 0)\n\ndef compare_versions(version1: str, version2: str) -> int:\n    \"\"\"Compara duas versões. Retorna -1, 0 ou 1\"\"\"\n    v1 = parse_version(version1)\n    v2 = parse_version(version2)\n    \n    if v1 < v2:\n        return -1\n    elif v1 > v2:\n        return 1\n    else:\n        return 0\n\ndef get_free_disk_space(path: str = \".\") -> int:\n    \"\"\"Retorna espaço livre em disco em bytes\"\"\"\n    try:\n        if os.name == 'nt':  # Windows\n            import ctypes\n            free_bytes = ctypes.c_ulonglong(0)\n            ctypes.windll.kernel32.GetDiskFreeSpaceExW(\n                ctypes.c_wchar_p(path),\n                ctypes.pointer(free_bytes),\n                None, None\n            )\n            return free_bytes.value\n        else:  # Unix/Linux\n            statvfs = os.statvfs(path)\n            return statvfs.f_frsize * statvfs.f_available\n    except Exception:\n        return 0\n\ndef is_directory_writable(directory: str) -> bool:\n    \"\"\"Verifica se diretório é gravável\"\"\"\n    try:\n        test_file = os.path.join(directory, 'test_write_permission.tmp')\n        with open(test_file, 'w') as f:\n            f.write('test')\n        os.remove(test_file)\n        return True\n    except Exception:\n        return False\n","size_bytes":13137}}}